{"mappings":"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","sources":["src/client/index.ts","src/client/GridStorage.ts","src/client/utils.ts","src/client/synAck.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { GridStorage, ThreadID } from \"./GridStorage\";\nimport {\n  SignedInvitation,\n  Invitation,\n  SelfEncrypted,\n  ReplyMessage,\n  SignedReply,\n  SignedBackup,\n  ReplyToInvite,\n  Decrypted,\n  SignedSelfEncrypted,\n  ReplyToInvitePayload,\n  ReplyPayload,\n  SignedTransport,\n  BackupPayload,\n  UnpackTaggedString,\n  SignedReplyToInvite,\n} from \"./types\";\nimport {\n  generateECDSAKeyPair,\n  generateECDHKeyPair,\n  exportKeyPair,\n  encryptPrivateKey,\n  getJWKthumbprint,\n  invariant,\n  decryptPrivateKey,\n  importKeyPair,\n  parseJWS,\n  deriveSharedSecret,\n  signJWS,\n  verifyJWS,\n  JWK,\n  ECDHCryptoKeyPair,\n  ECDSACryptoKeyPair,\n  exportKey,\n  Thumbprint,\n  SymmetricKey,\n  importPrivateKey,\n  importPublicKey,\n  decryptData,\n  encryptData,\n  parseJWSSync,\n} from \"./utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\nimport { synAck } from \"./synAck\";\n\nconst keyNicknames = new Map<string, string>();\nexport function setNickname(key: string, nickname: string) {\n  keyNicknames.set(key, nickname);\n}\n\nexport function getNickname(key: string) {\n  return keyNicknames.get(key) + \"_\" + key.substring(key.length - 6);\n}\n\nlet messageIdForInviteTesting: number | undefined;\nexport function setMessageIdForTesting(messageId: number) {\n  messageIdForInviteTesting = messageId;\n}\n\nconst MAX_MESSAGE_ID = Number.MAX_SAFE_INTEGER / 2;\n\nexport type DecryptedMessageType = {\n  message: string;\n  type: \"invite\" | \"message\";\n  from: string;\n  fromThumbprint: Thumbprint<\"ECDSA\">;\n  iat: number;\n  messageId: string;\n  minAck: string | undefined;\n  epkThumbprint: Thumbprint<\"ECDH\">;\n  relay?: string;\n};\n\n/**\n * In order to use the client over a websocket connection, everything on it\n * should be async functions. They also can't be arrow functions, because the\n * proxy is looking at the prototype to figure out if there is a function to\n * call.\n */\nexport class Client {\n  public isLocalClient = true; // The proxy will override this\n  /**\n   * The proxy uses this to distinguish between a complete Client object and a\n   * RemoteSetup object.\n   */\n  public isLoggedIn = true as const;\n  private clientNickname: string = Math.random().toString(36).slice(2);\n  async setClientNickname(nickname: string) {\n    this.clientNickname = nickname;\n    if (nickname) {\n      setNickname(this.thumbprint, this.clientNickname!);\n      setNickname(\n        await getJWKthumbprint(await exportKey(this.storageKeyPair.publicKey)),\n        `storage[${this.clientNickname!}]`,\n      );\n    }\n  }\n\n  constructor(\n    private storage: GridStorage,\n    private readonly thumbprint: Thumbprint<\"ECDSA\">,\n    private readonly identityKeyPair: ECDSACryptoKeyPair,\n    private readonly storageKeyPair: ECDHCryptoKeyPair,\n  ) {}\n\n  async getThumbprint() {\n    return this.thumbprint;\n  }\n\n  static async generateClient(\n    storage: GridStorage,\n    password: string,\n  ): Promise<Client> {\n    const identity = await generateECDSAKeyPair();\n    const storageKey = await generateECDHKeyPair();\n    const idJWKs = await exportKeyPair(identity);\n    const storageJWKs = await exportKeyPair(storageKey);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password,\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password,\n    );\n\n    const thumbprint = await getJWKthumbprint(idJWKs.publicKeyJWK);\n\n    storage.setItem(`identity:${thumbprint}`, {\n      id: {\n        jwk: idJWKs.publicKeyJWK,\n        private: encryptedIdentity,\n      },\n      storage: {\n        jwk: storageJWKs.publicKeyJWK,\n        private: encryptedStorageKey,\n      },\n    });\n\n    return Client.loadClient(storage, thumbprint, password);\n  }\n\n  static async loadFromBackup(\n    storage: GridStorage,\n    backup: BackupPayload | SignedBackup,\n    password: string,\n  ): Promise<Client> {\n    if (typeof backup === \"string\") {\n      const jws = await parseJWS(backup);\n      return Client.loadFromBackup(storage, jws.payload, password);\n    }\n\n    const identityPrivateKey = await decryptPrivateKey(\n      backup.identity.id.private,\n      password,\n    );\n    const storagePrivateKey = await decryptPrivateKey(\n      backup.identity.storage.private,\n      password,\n    );\n\n    const identityKeyPair: ECDSACryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: identityPrivateKey,\n        publicKeyJWK: backup.identity.id.jwk,\n      },\n      \"ecdsa\",\n    );\n    const storageKeyPair: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: storagePrivateKey,\n        publicKeyJWK: backup.identity.storage.jwk,\n      },\n      \"ecdh\",\n    );\n\n    await storage.loadIdentityBackup(backup);\n    const client = new Client(\n      storage,\n      backup.thumbprint,\n      identityKeyPair,\n      storageKeyPair,\n    );\n    return client;\n  }\n\n  static async loadClient(\n    storage: GridStorage,\n    thumbprint: Thumbprint<\"ECDSA\">,\n    password: string,\n  ) {\n    const storedData = storage.getItem(`identity:${thumbprint}`);\n    invariant(storedData, \"No identity found for thumbprint\");\n\n    const privateKeyJWK = await decryptPrivateKey(\n      storedData.id.private,\n      password,\n    );\n    const id = await importKeyPair(\n      { privateKeyJWK, publicKeyJWK: storedData.id.jwk },\n      \"ecdsa\",\n    );\n\n    const storageKeys: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: await decryptPrivateKey(\n          storedData.storage.private,\n          password,\n        ),\n        publicKeyJWK: storedData.storage.jwk,\n      },\n      \"ecdh\",\n    );\n\n    return new Client(storage, thumbprint, id, storageKeys);\n  }\n\n  async decryptFromSelf(message: SignedSelfEncrypted): Promise<string> {\n    const selfEncrypted = await parseJWS(\n      message,\n      this.identityKeyPair.publicKey,\n    );\n\n    const epk = await importPublicKey(\"ECDH\", selfEncrypted.header.epk);\n\n    const secret = await deriveSharedSecret(\n      this.storageKeyPair.privateKey,\n      epk,\n    );\n    const payload = await decryptData(\n      secret,\n      selfEncrypted.header.iv,\n      selfEncrypted.payload,\n    );\n    return payload;\n  }\n  async encryptToSelf(message: string) {\n    const epk = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(epk);\n\n    const secret = await deriveSharedSecret(\n      epk.privateKey,\n      this.storageKeyPair.publicKey,\n    );\n    const { iv, encrypted } = await encryptData(secret, message);\n\n    const selfEncrypted: SelfEncrypted = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"self-encrypted\",\n        iv,\n        epk: jwks.publicKeyJWK,\n      },\n      payload: encrypted,\n    };\n\n    const encryptedJWS = (await signJWS(\n      selfEncrypted.header,\n      selfEncrypted.payload,\n      this.identityKeyPair.privateKey,\n    )) as SignedSelfEncrypted;\n    // try {\n    invariant(await verifyJWS(encryptedJWS), \"Error encrypting message\");\n    const decryptedMessage = await this.decryptFromSelf(encryptedJWS);\n    invariant(decryptedMessage, \"Decrypted message is empty\");\n    invariant(\n      decryptedMessage === message ||\n        message === JSON.stringify(decryptedMessage),\n      \"Decrypted message mismatch\",\n    );\n    // } catch (e: any) {\n    //   throw new Error(`Error encrypting message: ${e?.message ?? e}`);\n    // }\n\n    return encryptedJWS;\n  }\n\n  async createInvitation({\n    note,\n    nickname,\n  }: {\n    note?: string;\n    nickname: string;\n  }): Promise<SignedInvitation> {\n    const { thumbprint, jwks } = await this.makeThreadKeys();\n\n    const invitation: Invitation = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"grid-invitation\",\n      },\n      payload: {\n        messageId: Number(\n          messageIdForInviteTesting ??\n            Math.floor(Math.random() * MAX_MESSAGE_ID),\n        ).toString(16),\n        epk: jwks.publicKeyJWK,\n        note,\n        nickname,\n      },\n    };\n    const signedInvitation = (await signJWS(\n      invitation.header,\n      invitation.payload,\n      this.identityKeyPair.privateKey,\n    )) as SignedInvitation;\n\n    this.storage.setItem(`invitation:${thumbprint}`, signedInvitation);\n    this.storage.appendItem(`invitations:${this.thumbprint}`, thumbprint, {\n      unique: true,\n    });\n    this.storage.setItem(\n      `threads:${this.thumbprint}`,\n      this.storage.queryItem(`threads:${this.thumbprint}`) ?? [],\n    );\n    this.notifySubscribers();\n    return signedInvitation;\n  }\n\n  async replyToInvitation(\n    signedInvite: SignedInvitation,\n    message: string,\n    nickname: string,\n    { setMyRelay }: { setMyRelay?: string } = {},\n  ) {\n    invariant(await verifyJWS(signedInvite), \"Invalid invitation signature\");\n    const invite = await parseJWS(signedInvite);\n\n    const threadId = await this.startThread(\n      signedInvite,\n      invite.payload.epk,\n      invite.header.jwk,\n    );\n    const reply = this.replyToThread(threadId, message, {\n      selfSign: true,\n      nickname,\n      setMyRelay,\n    });\n    return reply;\n  }\n\n  private async startThread(\n    signedInvite: SignedInvitation,\n    theirEPKJWK: JWK<\"ECDH\", \"public\">,\n    theirSignature: JWK<\"ECDSA\", \"public\">,\n    myThumbprint?: Thumbprint<\"ECDH\">,\n  ): Promise<ThreadID> {\n    if (!myThumbprint) {\n      const { thumbprint } = await this.makeThreadKeys();\n      myThumbprint = thumbprint;\n    }\n    const keyBackup = this.storage.getItem(\n      `encrypted-thread-key:${myThumbprint}`,\n    );\n    invariant(keyBackup, `Thread key not found ${myThumbprint}`);\n\n    const signatureThumbprint = await getJWKthumbprint(theirSignature);\n    invariant(\n      !myThumbprint || signatureThumbprint !== this.thumbprint,\n      \"Cannot start a thread with yourself\",\n    );\n\n    const thumbprints: Thumbprint<\"ECDH\">[] = [\n      await getJWKthumbprint(theirEPKJWK),\n      myThumbprint,\n    ].sort();\n\n    const threadId = ArrayBuffertohex(\n      await window.crypto.subtle.digest(\n        \"SHA-256\",\n        Buffer.from(thumbprints.join(\":\")),\n      ),\n    ) as ThreadID;\n\n    if (this.storage.queryItem(`thread-info:${this.thumbprint}:${threadId}`)) {\n      return threadId;\n    }\n\n    this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, {\n      missing: [],\n      windowSize: 5,\n      maxAck: undefined,\n      minAck: undefined,\n      syn: undefined,\n      myThumbprint,\n      theirEPK: theirEPKJWK,\n      signedInvite,\n      theirSignature,\n      relays: {},\n    });\n    this.storage.appendItem(`threads:${this.thumbprint}`, threadId);\n    await this.appendThread(signedInvite, threadId);\n\n    this.notifySubscribers();\n\n    return threadId;\n  }\n\n  async getThreads(): Promise<ThreadID[]> {\n    return this.storage.queryItem(`threads:${this.thumbprint}`) ?? [];\n  }\n  async getInvitationIds() {\n    return this.storage.queryItem(`invitations:${this.thumbprint}`) ?? [];\n  }\n  async getInvitations() {\n    return (await this.getInvitationIds()).map(\n      (t) => this.storage.getItem(`invitation:${t}`)!,\n    );\n  }\n\n  async getInvitation(thumbprint: Thumbprint<\"ECDH\">) {\n    return this.storage.getItem(`invitation:${thumbprint}`);\n  }\n\n  private async makeThreadKeys() {\n    const threadKey = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(threadKey);\n    const thumbprint = await getJWKthumbprint(jwks.publicKeyJWK);\n    setNickname(thumbprint, `thread[${this.clientNickname}]`);\n    const keyBackup = await this.encryptToSelf(JSON.stringify(jwks));\n    this.storage.setItem(`encrypted-thread-key:${thumbprint}`, keyBackup);\n\n    return { thumbprint, jwks };\n  }\n\n  private async readThreadSecret(threadThumbprint: ThreadID): Promise<{\n    secret: SymmetricKey;\n    epk: JWK<\"ECDH\", \"public\">;\n  }> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadThumbprint}`,\n    );\n    invariant(threadInfo, \"Thread not found\");\n\n    const publicJWK = threadInfo.theirEPK;\n    invariant(publicJWK, `Public key not found ${threadInfo.theirEPK}`);\n\n    const encryptedBackup = this.storage.getItem(\n      `encrypted-thread-key:${threadInfo.myThumbprint}`,\n    );\n    invariant(\n      typeof encryptedBackup === \"string\",\n      `Thread key not found ${threadInfo.myThumbprint}`,\n    );\n\n    type JWKPair = {\n      privateKeyJWK: JWK<\"ECDH\", \"private\">;\n      publicKeyJWK: JWK<\"ECDH\", \"public\">;\n    };\n    const jwks: JWKPair = JSON.parse(\n      await this.decryptFromSelf(encryptedBackup),\n    );\n    const pKey = await importPublicKey(\"ECDH\", publicJWK);\n    const privateKey = await importPrivateKey(\"ECDH\", jwks.privateKeyJWK);\n\n    return {\n      secret: await deriveSharedSecret(privateKey, pKey),\n      epk: jwks.publicKeyJWK,\n    };\n  }\n\n  public async replyToThread(\n    threadId: ThreadID,\n    message: string,\n    options?: {\n      selfSign?: boolean;\n      nickname?: string;\n      setMyRelay?: string;\n    },\n  ): Promise<{\n    reply: SignedReply;\n    threadId: ThreadID;\n    relay?: string;\n  }> {\n    const { secret, epk } = await this.readThreadSecret(threadId);\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const messageId =\n      threadInfo.syn ??\n      Number(\n        messageIdForInviteTesting\n          ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n          : Math.floor(Math.random() * MAX_MESSAGE_ID),\n      ).toString(16);\n    invariant(typeof messageId === \"string\", `Invalid message id ${messageId}`);\n    const nextId = incMessageId(messageId);\n    if (options?.setMyRelay) {\n      threadInfo.relays[this.thumbprint] = options.setMyRelay;\n    }\n\n    invariant(threadInfo.minAck, `Missing minAck in \"thread-info\" ${message}`);\n    let replyMessage: Decrypted<ReplyMessage | ReplyToInvite> = {\n      header: {\n        iat: 0,\n        alg: \"ES384\",\n        sub: \"grid-reply\",\n        re: threadId,\n        iv: \"\",\n        from: this.thumbprint,\n      },\n      payload: {\n        messageId: nextId,\n        message,\n        minAck: threadInfo.minAck,\n        relay: options?.setMyRelay,\n      },\n    };\n    // threadInfo.syn = nextId;\n    this.storage.setItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n      threadInfo,\n    );\n    if (options?.selfSign && options.nickname) {\n      const ack: Decrypted<ReplyToInvite> = {\n        header: {\n          ...replyMessage.header,\n          sub: \"reply-to-invite\",\n          jwk: await exportKey(this.identityKeyPair.publicKey),\n          invite: await getJWKthumbprint(threadInfo.theirEPK),\n          epk,\n        },\n        payload: {\n          ...replyMessage.payload,\n          nickname: options.nickname,\n          messageId: Number(\n            messageIdForInviteTesting\n              ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n              : Math.floor(Math.random() * MAX_MESSAGE_ID),\n          ).toString(16),\n        },\n      };\n      replyMessage = ack;\n    }\n\n    const { iv, encrypted } = await encryptData(secret, replyMessage.payload);\n    replyMessage.header.iv = iv;\n    const encryptedJWS = (await signJWS(\n      replyMessage.header,\n      encrypted,\n      this.identityKeyPair.privateKey,\n    )) as SignedReply;\n\n    invariant(\n      verifyJWS(encryptedJWS, this.identityKeyPair.publicKey),\n      \"Error encrypting message\",\n    );\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const relay = threadInfo.relays[theirThumbprint];\n\n    await this.appendThread(encryptedJWS, threadId);\n    return {\n      reply: encryptedJWS,\n      threadId,\n      relay,\n    };\n  }\n\n  public async appendThread(\n    encryptedMessage: SignedTransport,\n    threadId?: ThreadID,\n  ): Promise<{\n    threadId: ThreadID;\n    message: {\n      message: string;\n      type: \"invite\" | \"message\";\n    };\n    relay?: string;\n  }> {\n    const jws = parseJWSSync(encryptedMessage);\n    if (!threadId) {\n      switch (jws.header.sub) {\n        case \"grid-invitation\": {\n          // const invite = jws as Invitation;\n          throw new Error(\"Not Implemented\");\n          break;\n        }\n        case \"reply-to-invite\": {\n          const isValid = verifyJWS(encryptedMessage);\n          invariant(isValid, \"Expected a self-signed message\");\n          const reply = jws as ReplyToInvite;\n          invariant(reply.header.epk, \"First message must have an epk\");\n          invariant(\n            reply.header.invite,\n            'First message must have an \"invite\" header',\n          );\n          const invitationThumbprint = reply.header.invite;\n          const invitation = this.storage.getItem(\n            `invitation:${invitationThumbprint}`,\n          );\n          invariant(invitation, \"Invitation not found \" + invitationThumbprint);\n          const invitationJWS = await parseJWS(invitation);\n\n          const myThumbprint = await getJWKthumbprint(\n            invitationJWS.payload.epk,\n          );\n          threadId = await this.startThread(\n            invitation,\n            reply.header.epk,\n            reply.header.jwk,\n            myThumbprint,\n          );\n          // FALLS THROUGH\n        }\n        case \"grid-reply\": {\n          const reply = jws as ReplyMessage;\n          threadId ??= reply.header.re;\n          const threadInfo = this.storage.getItem(\n            `thread-info:${this.thumbprint}:${threadId}`,\n          );\n\n          const fromMe = reply.header.from === this.thumbprint;\n          let isValid = false;\n          if (fromMe) {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              this.identityKeyPair.publicKey,\n            );\n          } else {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              threadInfo.theirSignature,\n            );\n          }\n          invariant(isValid, \"Invalid message signature\");\n\n          return this.appendThread(encryptedMessage, threadId);\n        }\n      }\n    }\n    invariant(threadId, \"Thread not found\");\n    const message = await this.decryptMessage(threadId, encryptedMessage);\n    const threadInfo = {\n      ...this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`),\n    };\n\n    const fromMe = message.fromThumbprint === this.thumbprint;\n\n    let isValid;\n    if (fromMe) {\n      isValid = await verifyJWS(\n        encryptedMessage,\n        this.identityKeyPair.publicKey,\n      );\n    } else {\n      isValid = await verifyJWS(encryptedMessage, threadInfo.theirSignature);\n    }\n    invariant(isValid, \"Invalid message signature\");\n    const storeMessage = synAck(\n      fromMe\n        ? {\n            syn: message.messageId,\n          }\n        : {\n            ack: message.messageId,\n          },\n      threadInfo,\n    );\n\n    if (storeMessage) {\n      const m = this.storage.queryItem(\n        `keyed-messages:${this.thumbprint}:${threadId}`,\n      )?.messages;\n      invariant(\n        m ? !m.includes(encryptedMessage) : true,\n        // m?.[0] !== encryptedMessage || lastMessage !== encryptedMessage,\n        `Message already exists in thread ${JSON.stringify(\n          {\n            nickname: this.clientNickname,\n            messageId: message.messageId,\n            sub: jws.header.sub,\n            threadId,\n            messageIndex: m?.indexOf(encryptedMessage),\n          },\n          null,\n          2,\n        )}`,\n      );\n      if (message.relay) {\n        threadInfo.relays[await getJWKthumbprint(threadInfo.theirSignature)] =\n          message.relay;\n\n        if (\n          message.relay &&\n          message.relay.match(/^https?:\\/\\/ntfy.sh\\/[^.]+$/)\n        ) {\n          threadInfo.relays[this.thumbprint] = message.relay;\n        }\n      }\n      this.storage.setItem(\n        `thread-info:${this.thumbprint}:${threadId}`,\n        threadInfo,\n      );\n      this.storage.storeMessage(\n        this.thumbprint,\n        threadId,\n        message.messageId,\n        encryptedMessage,\n      );\n      this.notifySubscribers();\n    } else {\n      console.warn(\"Skipping message\", message.messageId);\n    }\n    return {\n      threadId: threadId,\n      message,\n      relay: message.relay,\n    };\n  }\n\n  public async decryptThread(threadId: ThreadID) {\n    const thread = await this.getEncryptedThread(threadId);\n    const messages = await Promise.all(\n      thread.map(async (message) => {\n        return typeof message === \"string\"\n          ? this.decryptMessage(threadId, message)\n          : message;\n      }),\n    );\n    messages.sort((a, b) => {\n      if (a.from !== b.from) {\n        if (a.minAck && a.minAck < b.messageId) {\n          return 1;\n        }\n        if (b.minAck && b.minAck < a.messageId) {\n          return 1;\n        }\n      }\n      const order =\n        (a.type === \"invite\" ? -1 : 0) ||\n        (b.type === \"invite\" ? 1 : 0) ||\n        b.iat - a.iat ||\n        (a.from === b.from ? a.messageId.localeCompare(b.messageId) : 0);\n\n      return order;\n    });\n    return messages;\n  }\n  public async decryptMessage(\n    threadId: ThreadID,\n    encryptedMessage: SignedTransport,\n  ): Promise<DecryptedMessageType> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n    );\n    const jws = await parseJWS(encryptedMessage, null);\n    invariant(threadInfo, \"Thread not found\");\n\n    if (jws.header.sub === \"grid-invitation\") {\n      // Looks like an Invite\n      invariant(await verifyJWS(encryptedMessage), \"Invalid message signature\");\n      const jwsInvite: Invitation = jws as Invitation;\n\n      const message = `Invite from ${jwsInvite.payload.nickname}.\\nNote: ${\n        jwsInvite.payload.note ?? \"(none)\"\n      }`;\n\n      const from = await getJWKthumbprint(jwsInvite.header.jwk);\n      if (jwsInvite.payload.nickname) {\n        setNickname(from, jwsInvite.payload.nickname);\n      }\n      return {\n        from: getNickname(from),\n        fromThumbprint: from,\n        epkThumbprint: await getJWKthumbprint(jwsInvite.payload.epk),\n        message,\n        type: \"invite\",\n        iat: jwsInvite.header.iat,\n        messageId: jwsInvite.payload.messageId,\n        minAck: undefined,\n      };\n    }\n    const reply = jws as ReplyMessage | ReplyToInvite;\n    const { secret } = await this.readThreadSecret(threadId);\n    const payload = await decryptData<ReplyToInvitePayload | ReplyPayload>(\n      secret,\n      jws.header.iv,\n      reply.payload,\n    );\n    const from = reply.header.from;\n\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const epkThumbprint =\n      from === theirThumbprint\n        ? await getJWKthumbprint(threadInfo.theirEPK)\n        : threadInfo.myThumbprint;\n\n    return {\n      from: getNickname(from),\n      fromThumbprint: from,\n      epkThumbprint,\n      message: payload.message,\n      type: \"message\",\n      iat: reply.header.iat,\n      messageId: payload.messageId,\n      minAck: payload.minAck,\n      relay: payload.relay,\n    };\n  }\n\n  public async getEncryptedThread(threadId: ThreadID) {\n    return this.storage.readMessages(this.thumbprint, threadId);\n  }\n\n  public async getThreadInfo(thread: ThreadID) {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${thread}`,\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const myRelay = threadInfo.relays[this.thumbprint];\n\n    return {\n      myRelay,\n      myNickname: getNickname(this.thumbprint),\n      theirNickname: getNickname(\n        await getJWKthumbprint(threadInfo.theirSignature),\n      ),\n    };\n  }\n\n  async makeBackup(password: string) {\n    const idJWKs = await exportKeyPair(this.identityKeyPair);\n    const storageJWKs = await exportKeyPair(this.storageKeyPair);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password,\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password,\n    );\n    const payload = await this.storage.makeIdentityBackup(\n      this.thumbprint,\n      encryptedIdentity,\n      encryptedStorageKey,\n    );\n\n    return signJWS(\n      {\n        alg: \"ES384\",\n        jwk: idJWKs.publicKeyJWK,\n      },\n      payload,\n      this.identityKeyPair.privateKey,\n    ) as Promise<SignedBackup>;\n  }\n\n  private notifySubscribers() {\n    for (const sub of this.subscriptions) {\n      try {\n        sub?.();\n      } catch (e) {\n        // Ignore\n      }\n    }\n  }\n  private subscriptions = new Set<() => void>();\n  public subscribe(onChange: () => void) {\n    this.subscriptions ??= new Set<() => void>();\n    this.subscriptions.add(onChange);\n\n    return () => {\n      this.subscriptions.delete(onChange);\n    };\n  }\n}\n\nexport function incMessageId(messageId: string) {\n  let nextId = parseInt(messageId, 16) + 1;\n  if (nextId >= MAX_MESSAGE_ID) {\n    nextId = 1;\n  }\n  invariant(!Number.isNaN(nextId), `Invalid message id ${messageId} ${nextId}`);\n  const n = nextId.toString(16);\n  invariant(\n    !Number.isNaN(n),\n    `Invalid message toString ${messageId} ${nextId}`,\n  );\n  return n;\n}\n\nexport type {\n  BackupPayload,\n  Invitation,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedTransport,\n  Thumbprint,\n  ThreadID,\n  UnpackTaggedString,\n};\nexport { GridStorage };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  BackupPayload,\n  SignedInvitation,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n  ThreadInfoData,\n} from \"./types\";\nimport { EncryptedPrivateKey, invariant, JWK, Thumbprint } from \"./utils\";\n\nexport type ThreadID = TaggedString<\"ThreadID\">;\n\ntype Key<Type extends StoredDataTypes[\"type\"]> = `${Type}:${Extract<\n  StoredDataTypes,\n  { type: Type }\n>[\"keyType\"]}`;\nexport type GridStorageType = {\n  hasItem<Type extends StoredDataTypes[\"type\"]>(key: Key<Type>): boolean;\n  removeItem: <Type extends StoredDataTypes[\"type\"]>(key: Key<Type>) => null;\n  queryItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>,\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"] | null;\n  getItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>,\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"];\n  setItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>,\n    value: Extract<StoredDataTypes, { type: Type }>[\"data\"],\n  ) => void;\n  appendItem: <\n    Type extends StoredDataTypes[\"type\"],\n    V extends Extract<StoredDataTypes, { type: Type }>[\"data\"],\n  >(\n    key: Key<Type>,\n    value: V extends Array<any> ? V[number] : never,\n    options?: { unique?: boolean },\n  ) => void;\n};\nexport type StoredIdentity = {\n  id: {\n    jwk: JWK<\"ECDSA\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDSA\">;\n  };\n  storage: {\n    jwk: JWK<\"ECDH\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDH\">;\n  };\n};\n\ntype StoredDataTypes =\n  | {\n      type: \"identity\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: StoredIdentity;\n    }\n  | {\n      type: \"thread-info\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: ThreadInfoData;\n    }\n  | { type: \"invitation\"; keyType: Thumbprint<\"ECDH\">; data: SignedInvitation }\n  | {\n      type: \"invitations\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: Thumbprint<\"ECDH\">[];\n    }\n  | {\n      type: \"keyed-messages\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: {\n        min: string;\n        max: string;\n        messages: Array<SignedTransport>;\n      };\n    }\n  | {\n      type: \"encrypted-thread-key\";\n      keyType: Thumbprint<\"ECDH\">;\n      data: SignedSelfEncrypted;\n    }\n  | { type: \"threads\"; keyType: Thumbprint<\"ECDSA\">; data: Array<ThreadID> };\n\nexport class GridStorage implements GridStorageType {\n  protected data: {\n    get: (key: string) => any;\n    has: (key: string) => boolean;\n    delete: (key: string) => void;\n    set: (key: string, value: any) => void;\n  } = new Map<string, any>();\n\n  debugData() {\n    return Object.fromEntries((this.data as any).entries());\n  }\n\n  async loadIdentityBackup(backup: BackupPayload) {\n    this.setItem(`identity:${backup.thumbprint}`, backup.identity);\n    Object.entries(backup.invites ?? {}).forEach(([key, value]) => {\n      this.appendItem(\n        `invitations:${backup.thumbprint}`,\n        key as Thumbprint<\"ECDH\">,\n        { unique: true },\n      );\n      this.setItem(`invitation:${key as Thumbprint<\"ECDH\">}`, value);\n    });\n    Object.entries(backup.encryptedThreadKeys).forEach(([thumbprint, key]) => {\n      this.setItem(\n        `encrypted-thread-key:${thumbprint as Thumbprint<\"ECDH\">}`,\n        key,\n      );\n    });\n    Object.entries(backup.threads).forEach(([id, thread]) => {\n      const threadId = id as ThreadID;\n      this.appendItem(`threads:${backup.thumbprint}`, threadId);\n      this.setItem(\n        `thread-info:${backup.thumbprint}:${threadId}`,\n        thread.threadInfo,\n      );\n      this.setItem(\n        `keyed-messages:${backup.thumbprint}:${threadId}`,\n        thread.messages,\n      );\n    });\n  }\n\n  async makeIdentityBackup(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    idPrivateKey: EncryptedPrivateKey<\"ECDSA\">,\n    storagePrivateKey: EncryptedPrivateKey<\"ECDH\">,\n  ): Promise<BackupPayload> {\n    const identity = this.getItem(`identity:${thumbprint}`);\n    const encryptedThreadKeys: BackupPayload[\"encryptedThreadKeys\"] = {};\n\n    return {\n      thumbprint,\n      identity: {\n        id: {\n          jwk: identity.id.jwk,\n          private: idPrivateKey,\n        },\n        storage: {\n          jwk: identity.storage.jwk,\n          private: storagePrivateKey,\n        },\n      },\n      invites: this.queryItem(`invitations:${thumbprint}`)?.reduce(\n        (memo, key) => {\n          memo[key] = this.getItem(`invitation:${key}`);\n\n          encryptedThreadKeys[key] = this.getItem(\n            `encrypted-thread-key:${key}`,\n          );\n          return memo;\n        },\n        {} as NonNullable<BackupPayload[\"invites\"]>,\n      ),\n      threads:\n        (await this.queryItem(`threads:${thumbprint}`)?.reduce(\n          async (m, key) => {\n            const memo = await m;\n            const threadInfo = this.getItem(`thread-info:${thumbprint}:${key}`);\n            const messages = this.getItem(\n              `keyed-messages:${thumbprint}:${key}`,\n            );\n            encryptedThreadKeys[threadInfo.myThumbprint] = this.getItem(\n              `encrypted-thread-key:${threadInfo.myThumbprint}`,\n            );\n\n            memo[key] = {\n              threadInfo,\n              messages,\n            };\n            return memo;\n          },\n          Promise.resolve({} as NonNullable<BackupPayload[\"threads\"]>),\n        )) ?? {},\n\n      encryptedThreadKeys,\n    };\n  }\n\n  hasItem: GridStorageType[\"hasItem\"] = (key) => {\n    return this.data.has(key);\n  };\n\n  removeItem: GridStorageType[\"removeItem\"] = (key) => {\n    this.data.delete(key);\n    return null;\n  };\n\n  queryItem: GridStorageType[\"queryItem\"] = (key) => {\n    return this.data.get(key);\n  };\n\n  getItem: GridStorageType[\"getItem\"] = (key) => {\n    invariant(this.hasItem(key), `Key ${key} not found in storage.`);\n    return this.data.get(key);\n  };\n\n  setItem: GridStorageType[\"setItem\"] = (key, value) => {\n    this.data.set(key, value);\n  };\n\n  appendItem: GridStorageType[\"appendItem\"] = (\n    key,\n    value,\n    { unique = false } = {},\n  ) => {\n    let arr: any = this.queryItem(key);\n    if (!Array.isArray(arr)) {\n      arr = [];\n    }\n    if (unique && arr.includes(value)) {\n      return;\n    }\n    arr.push(value);\n    this.setItem(key, arr);\n  };\n\n  public storeMessage(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    threadId: ThreadID,\n    messageId: string,\n    message: SignedTransport,\n  ) {\n    const index = this.queryItem(\n      `keyed-messages:${thumbprint}:${threadId}`,\n    ) ?? {\n      min: messageId,\n      max: messageId,\n      messages: [] as SignedTransport[],\n    };\n    index.messages.push(message);\n    this.setItem(`keyed-messages:${thumbprint}:${threadId}`, index);\n  }\n  public readMessages(thumbprint: Thumbprint<\"ECDSA\">, threadId: ThreadID) {\n    const { messages } = this.getItem(\n      `keyed-messages:${thumbprint}:${threadId}`,\n    );\n    return messages;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  utf8tob64u,\n  hextob64u,\n  ArrayBuffertohex,\n  b64utoutf8,\n  hextoArrayBuffer,\n  b64utohex,\n  rstrtohex,\n} from \"jsrsasign\";\nimport { setNickname } from \"./index\";\nimport {\n  BackupJWS,\n  Encrypted,\n  Invitation,\n  ReplyMessage,\n  ReplyToInvite,\n  SelfEncrypted,\n  SignedBackup,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n} from \"./types\";\n\nexport const b64uToBuffer = (str: string) =>\n  Buffer.from(str.replace(\"-\", \"+\").replace(\"_\", \"/\"), \"base64\");\n\nexport const bufferToB64u = (src: Uint8Array | ArrayBuffer) =>\n  Buffer.from(src)\n    .toString(\"base64\")\n    .replaceAll(\"+\", \"-\")\n    .replaceAll(\"/\", \"_\")\n    .replaceAll(\"=\", \"\");\nexport const ecdhAlg = {\n  name: \"ECDH\",\n  namedCurve: \"P-384\",\n} as const;\nexport const ecdsaAlg = {\n  name: \"ECDSA\",\n  namedCurve: \"P-384\",\n} as const;\nconst ecdsaKeyUseages = [\"sign\", \"verify\"] as const;\nexport const ecdsaSignAlg = {\n  name: \"ECDSA\",\n  hash: { name: \"SHA-384\" },\n} as const;\n\nconst keySymbol = Symbol(\"keySymbol\");\ntype Visibility = \"public\" | \"private\";\ntype AlgorithmType = \"ECDSA\" | \"ECDH\";\ntype TaggedKey<T = [AlgorithmType, Visibility]> = CryptoKey & {\n  [keySymbol]: T;\n};\nexport type EncryptedPrivateKey<T = AlgorithmType> = TaggedString<\n  [T, \"private\"]\n>;\nexport type SymmetricKey = CryptoKey & { [keySymbol]: \"AES-GCM\" };\n\nexport type ECDHCryptoKey<V = Visibility> = TaggedKey<[\"ECDH\", V]>;\nexport type ECDSACryptoKey<V = Visibility> = TaggedKey<[\"ECDSA\", V]>;\nexport type TaggedCryptoKeyPair<T = AlgorithmType> = {\n  publicKey: TaggedKey<[T, \"public\"]>;\n  privateKey: TaggedKey<[T, \"private\"]>;\n};\nexport type ECDSACryptoKeyPair = TaggedCryptoKeyPair<\"ECDSA\">;\nexport type ECDHCryptoKeyPair = TaggedCryptoKeyPair<\"ECDH\">;\n\nexport type JWK<T = \"ECDSA\" | \"ECDH\", V = Visibility> = JsonWebKey & {\n  [keySymbol]: [T, V];\n};\nexport type Thumbprint<T = AlgorithmType> = string & {\n  [keySymbol]: T;\n};\n\nexport async function generateECDSAKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(\n    ecdsaAlg,\n    true,\n    ecdsaKeyUseages,\n  )) as ECDSACryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDSA`);\n\n  return keyPair;\n}\nexport async function generateECDHKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(ecdhAlg, true, [\n    \"deriveKey\",\n    \"deriveBits\",\n  ])) as ECDHCryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDH`);\n\n  return keyPair;\n}\nexport function invariant<T>(condition: T, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexport async function deriveSharedSecret(\n  privateKey: TaggedKey<[\"ECDH\", \"private\"]>,\n  publicKey: TaggedKey<[\"ECDH\", \"public\"]>,\n): Promise<SymmetricKey> {\n  const bits = await window.crypto.subtle.deriveBits(\n    {\n      name: ecdhAlg.name,\n      public: publicKey,\n    },\n    privateKey,\n    256,\n  );\n  return (await window.crypto.subtle.importKey(\n    \"raw\",\n    bits,\n    { name: \"AES-GCM\" },\n    false,\n    [\"encrypt\", \"decrypt\"],\n  )) as SymmetricKey;\n}\n\ntype Header = {\n  iat?: number;\n  alg: \"ES384\";\n  jwk?: JWK<any, any>;\n};\nexport async function signJWS<H extends Header = Header, P = object | string>(\n  header: H,\n  payload: P,\n  privateKey: ECDSACryptoKey<\"private\">,\n): Promise<string> {\n  const unixTimetsamp = Math.floor(Date.now() / 1000);\n  header.iat = unixTimetsamp;\n\n  const encodedHeader = utf8tob64u(JSON.stringify(header));\n\n  const encodedPayload = utf8tob64u(\n    typeof payload === \"string\" ? payload : JSON.stringify(payload),\n  );\n  const dataToSign = `${encodedHeader}.${encodedPayload}`;\n\n  const signature = await window.crypto.subtle.sign(\n    ecdsaSignAlg,\n    privateKey,\n    new TextEncoder().encode(dataToSign),\n  );\n\n  // Step 5: Encode the signature\n  const encodedSignature = hextob64u(ArrayBuffertohex(signature));\n\n  // Step 6: Concatenate the encoded parts\n  const jws = `${dataToSign}.${encodedSignature}`;\n\n  return jws;\n}\nexport async function verifyJWS(\n  jws: string,\n  pubKey?: ECDSACryptoKey<\"public\"> | JWK<\"ECDSA\", \"public\"> | null,\n): Promise<boolean> {\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1);\n  }\n\n  const [header, payload, signature] = jws.split(\".\");\n  const signedData = `${header}.${payload}`;\n\n  if (!pubKey) {\n    let headerObj;\n    try {\n      headerObj = JSON.parse(b64utoutf8(header));\n    } catch (e) {\n      // ignore JSON parse errors\n    }\n    if (headerObj && \"jwk\" in headerObj && typeof headerObj.jwk === \"object\") {\n      const pubKey = await importPublicKey<\"ECDSA\">(\"ECDSA\", headerObj.jwk);\n      return verifyJWS(jws, pubKey);\n    }\n    return false;\n  }\n\n  if (\"kty\" in pubKey) {\n    pubKey = await importPublicKey(\"ECDSA\", pubKey);\n  }\n\n  const isValid = await window.crypto.subtle.verify(\n    { name: ecdsaAlg.name, hash: { name: \"SHA-384\" } },\n    pubKey as CryptoKey,\n    hextoArrayBuffer(b64utohex(signature)),\n    new TextEncoder().encode(signedData),\n  );\n  return isValid;\n}\nexport async function getJWKthumbprint<T = AlgorithmType>(\n  jwk: JWK<T, any>,\n): Promise<Thumbprint<T>> {\n  invariant(jwk.kty === \"EC\", \"Unsupported key type\");\n  const s = {\n    crf: jwk.crv,\n    kty: jwk.kty,\n    x: jwk.x,\n    y: jwk.y,\n  };\n  const hex = rstrtohex(JSON.stringify(s));\n  const sha256 = await window.crypto.subtle.digest(\n    \"SHA-256\",\n    hextoArrayBuffer(hex),\n  );\n\n  return `id-${hextob64u(ArrayBuffertohex(sha256))}` as any;\n}\n\nexport function exportKey<T = AlgorithmType, V = Visibility>(\n  key: TaggedKey<[T, V]>,\n) {\n  return window.crypto.subtle.exportKey(\"jwk\", key) as Promise<JWK<T, V>>;\n}\n\nexport async function exportKeyPair<T = AlgorithmType>(\n  keyPair: TaggedCryptoKeyPair<T>,\n) {\n  const privateKeyJWK = await exportKey(keyPair.privateKey);\n  const publicKeyJWK = await exportKey(keyPair.publicKey);\n  return { privateKeyJWK, publicKeyJWK };\n}\nexport async function encryptPrivateKey<T = AlgorithmType>(\n  privateKeyJWK: JWK<T, \"private\">,\n  password: string,\n): Promise<EncryptedPrivateKey<T>> {\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"],\n  );\n\n  const salt = window.crypto.getRandomValues(new Uint8Array(16));\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"],\n  );\n\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const privateKeyString = JSON.stringify(privateKeyJWK);\n  const encryptedPrivateKey = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    enc.encode(privateKeyString),\n  );\n\n  return [\n    Buffer.from(encryptedPrivateKey).toString(\"base64\"),\n    Buffer.from(iv).toString(\"base64\"),\n    Buffer.from(salt).toString(\"base64\"),\n  ].join(\".\") as EncryptedPrivateKey<T>;\n}\nexport async function decryptPrivateKey<T = AlgorithmType>(\n  str: TaggedString<[T, \"private\"]>,\n  password: string,\n): Promise<JWK<T, \"private\">> {\n  const [encryptedPrivateKey, iv, salt] = str\n    .split(\".\")\n    .map((b64) => Uint8Array.from(Buffer.from(b64, \"base64\")));\n  invariant(encryptedPrivateKey && iv && salt, \"Invalid encrypted private key\");\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"],\n  );\n\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"],\n  );\n\n  const decryptedPrivateKey = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    encryptedPrivateKey,\n  );\n\n  const privateKeyJWK = JSON.parse(\n    new TextDecoder().decode(decryptedPrivateKey),\n  );\n  return privateKeyJWK;\n}\nexport async function parseJWS<\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string,\n>(jws: J, pubKey?: ECDSACryptoKey<\"public\"> | null) {\n  if (pubKey !== null) {\n    const isValid = await verifyJWS(jws, pubKey);\n    invariant(isValid, `JWS verification failed`);\n  }\n  return parseJWSSync(jws);\n}\nexport function parseJWSSync<\n  T extends { header: unknown; payload: unknown },\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string,\n>(\n  jws: J,\n): J extends SignedInvitation\n  ? Invitation\n  : J extends SignedReply\n    ? ReplyMessage\n    : J extends SignedReplyToInvite\n      ? ReplyToInvite\n      : J extends SignedSelfEncrypted\n        ? SelfEncrypted\n        : J extends SignedBackup\n          ? BackupJWS\n          : T {\n  invariant(typeof jws === \"string\", \"Expected a string\");\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1) as any;\n  }\n  const [encodedHeader, encodedPayload] = jws.split(\".\");\n  const header = JSON.parse(b64utoutf8(encodedHeader));\n  let payload = b64utoutf8(encodedPayload);\n  try {\n    payload = JSON.parse(payload);\n  } catch (e) {\n    // ignore JSON parse errors\n  }\n\n  return { header, payload } as any;\n}\n\nexport async function importPrivateKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"private\">,\n): Promise<TaggedKey<[T, \"private\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"],\n  )) as TaggedKey<[T, \"private\"]>;\n}\nexport async function importPublicKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"public\">,\n): Promise<TaggedKey<[T, \"public\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [] : [\"verify\"],\n  )) as TaggedKey<[T, \"public\"]>;\n}\n\nexport async function importKeyPair<T = AlgorithmType>(\n  t: {\n    privateKeyJWK: JWK<T, \"private\">;\n    publicKeyJWK: JWK<T, \"public\">;\n  },\n  type: \"ecdsa\" | \"ecdh\" = \"ecdh\",\n): Promise<{\n  privateKey: TaggedKey<[T, \"private\"]>;\n  publicKey: TaggedKey<[T, \"public\"]>;\n}> {\n  return {\n    privateKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.privateKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"],\n    )) as TaggedKey<[T, \"private\"]>,\n    publicKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.publicKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [] : [\"verify\"],\n    )) as TaggedKey<[T, \"public\"]>,\n  };\n}\n\nconst MIN_MESSAGE_SIZE = 30;\nexport async function encryptData<T extends string | object>(\n  secret: SymmetricKey,\n  message: T,\n): Promise<{\n  iv: string;\n  encrypted: Encrypted<T>;\n}> {\n  try {\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    let msg = JSON.stringify({\n      m: message,\n    });\n    if (msg.length < MIN_MESSAGE_SIZE) {\n      msg = JSON.stringify({\n        random: ArrayBuffertohex(\n          window.crypto.getRandomValues(new Uint8Array(MIN_MESSAGE_SIZE / 2))\n            .buffer,\n        ),\n        m: message,\n      });\n    }\n    const encrypted = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      secret,\n      new TextEncoder().encode(msg),\n    );\n    return {\n      iv: Buffer.from(iv).toString(\"base64\"),\n      encrypted: bufferToB64u(encrypted) as Encrypted<T>,\n    };\n  } catch (e: any) {\n    throw new Error(\"Failed to encrypt \" + e?.message);\n  }\n}\n\nexport async function decryptData<T extends string | object>(\n  secret: SymmetricKey,\n  iv: string,\n  encryptedPayload: Encrypted<T>,\n): Promise<T> {\n  try {\n    const payloadBuffer = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: b64uToBuffer(iv),\n      },\n      secret,\n      b64uToBuffer(encryptedPayload),\n    );\n    const decoded = new TextDecoder().decode(payloadBuffer);\n    const decrypted = JSON.parse(decoded);\n\n    return (decrypted?.m ?? decrypted) as T;\n  } catch (e: any) {\n    throw new Error(\"Failed to decrypt \" + e?.message);\n  }\n}\n","import { incMessageId } from \"./index\";\n\nexport type SynAckState = {\n  syn: string | undefined;\n  minAck: string | undefined;\n  maxAck: string | undefined;\n  missing: string[];\n  windowSize: number;\n};\nexport function synAck(\n  id: { syn: string } | { ack: string },\n  state: SynAckState,\n) {\n  if (\"syn\" in id) {\n    if (state.syn === undefined) {\n      state.syn = id.syn;\n    } else if (id.syn === incMessageId(state.syn)) {\n      state.syn = id.syn;\n    } else {\n      throw new Error(\n        `Syn out of order ${id.syn} - Expected: ${incMessageId(state.syn)}`,\n      );\n    }\n  } else {\n    if (!state.minAck || !state.maxAck) {\n      // initialize\n      state.minAck = id.ack;\n      state.maxAck = id.ack;\n    } else if (id.ack === incMessageId(state.maxAck)) {\n      // Next expected message (max)\n      state.maxAck = id.ack;\n      if (id.ack === incMessageId(state.minAck)) {\n        // min/ax are in sync --- This is the ideal scenario\n        state.minAck = id.ack;\n      }\n    } else if (id.ack === incMessageId(state.minAck)) {\n      // Increment the minAck\n      state.minAck = id.ack;\n    } else if (id.ack <= state.minAck || id.ack === state.maxAck) {\n      // Ignore duplicate\n      return false;\n    } else if (id.ack > state.maxAck) {\n      const min = parseInt(state.minAck, 16);\n      const ack = parseInt(id.ack, 16);\n\n      if (ack - min >= state.windowSize) {\n        throw new Error(\n          `Missing ${ack - min} messages between ${state.minAck} and ${id.ack}`,\n        );\n      }\n      if (state.missing.length === 0) {\n        for (let i = min + 1; i < ack; i++) {\n          state.missing.push(i.toString(16));\n        }\n      }\n      const i = state.missing.findIndex((m) => m === id.ack);\n      if (i !== -1) {\n        state.missing.splice(i, 1);\n      }\n      state.maxAck = id.ack;\n    } else {\n      throw new Error(\n        `Ack out of order ${JSON.stringify(id)} ${JSON.stringify(state)}`,\n      );\n    }\n  }\n  return true;\n}\n"],"names":[],"version":3,"file":"index.js.map"}
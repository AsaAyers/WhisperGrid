{"version":3,"sources":["../client/utils.ts","../client/synAck.ts","../client/index.ts","../client/GridStorage.ts","viewEncryptedThread.ts","mainClientMenu.ts","index.ts"],"names":[],"mappings":"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","file":"cli.js","sourceRoot":"../src/cli","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  utf8tob64u,\n  hextob64u,\n  ArrayBuffertohex,\n  b64utoutf8,\n  hextoArrayBuffer,\n  b64utohex,\n  rstrtohex,\n} from \"jsrsasign\";\nimport { setNickname } from \"./index\";\nimport {\n  BackupJWS,\n  Encrypted,\n  Invitation,\n  ReplyMessage,\n  ReplyToInvite,\n  SelfEncrypted,\n  SignedBackup,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n} from \"./types\";\n\nexport const b64uToBuffer = (str: string) =>\n  Buffer.from(str.replace(\"-\", \"+\").replace(\"_\", \"/\"), \"base64\");\n\nexport const bufferToB64u = (src: Uint8Array | ArrayBuffer) =>\n  Buffer.from(src)\n    .toString(\"base64\")\n    .replace(\"+\", \"-\")\n    .replace(\"/\", \"_\")\n    .replace(\"=\", \"\");\nexport const ecdhAlg = {\n  name: \"ECDH\",\n  namedCurve: \"P-384\",\n} as const;\nexport const ecdsaAlg = {\n  name: \"ECDSA\",\n  namedCurve: \"P-384\",\n} as const;\nconst ecdsaKeyUseages = [\"sign\", \"verify\"] as const;\nexport const ecdsaSignAlg = {\n  name: \"ECDSA\",\n  hash: { name: \"SHA-384\" },\n} as const;\n\nconst keySymbol = Symbol(\"keySymbol\");\ntype Visibility = \"public\" | \"private\";\ntype AlgorithmType = \"ECDSA\" | \"ECDH\";\ntype TaggedKey<T = [AlgorithmType, Visibility]> = CryptoKey & {\n  [keySymbol]: T;\n};\nexport type EncryptedPrivateKey<T = AlgorithmType> = TaggedString<\n  [T, \"private\"]\n>;\nexport type SymmetricKey = CryptoKey & { [keySymbol]: \"AES-GCM\" };\n\nexport type ECDHCryptoKey<V = Visibility> = TaggedKey<[\"ECDH\", V]>;\nexport type ECDSACryptoKey<V = Visibility> = TaggedKey<[\"ECDSA\", V]>;\nexport type TaggedCryptoKeyPair<T = AlgorithmType> = {\n  publicKey: TaggedKey<[T, \"public\"]>;\n  privateKey: TaggedKey<[T, \"private\"]>;\n};\nexport type ECDSACryptoKeyPair = TaggedCryptoKeyPair<\"ECDSA\">;\nexport type ECDHCryptoKeyPair = TaggedCryptoKeyPair<\"ECDH\">;\n\nexport type JWK<T = \"ECDSA\" | \"ECDH\", V = Visibility> = JsonWebKey & {\n  [keySymbol]: [T, V];\n};\nexport type Thumbprint<T = AlgorithmType> = string & {\n  [keySymbol]: T;\n};\n\nexport async function generateECDSAKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(\n    ecdsaAlg,\n    true,\n    ecdsaKeyUseages\n  )) as ECDSACryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDSA`);\n\n  return keyPair;\n}\nexport async function generateECDHKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(ecdhAlg, true, [\n    \"deriveKey\",\n    \"deriveBits\",\n  ])) as ECDHCryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDH`);\n\n  return keyPair;\n}\nexport function invariant<T>(condition: T, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexport async function deriveSharedSecret(\n  privateKey: TaggedKey<[\"ECDH\", \"private\"]>,\n  publicKey: TaggedKey<[\"ECDH\", \"public\"]>\n): Promise<SymmetricKey> {\n  const bits = await window.crypto.subtle.deriveBits(\n    {\n      name: ecdhAlg.name,\n      public: publicKey,\n    },\n    privateKey,\n    256\n  );\n  return (await window.crypto.subtle.importKey(\n    \"raw\",\n    bits,\n    { name: \"AES-GCM\" },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  )) as SymmetricKey;\n}\n\ntype Header = {\n  iat?: number;\n  alg: \"ES384\";\n  jwk?: JWK<any, any>;\n};\nexport async function signJWS<H extends Header = Header, P = object | string>(\n  header: H,\n  payload: P,\n  privateKey: ECDSACryptoKey<\"private\">\n): Promise<string> {\n  const unixTimetsamp = Math.floor(Date.now() / 1000);\n  header.iat = unixTimetsamp;\n\n  const encodedHeader = utf8tob64u(JSON.stringify(header));\n\n  const encodedPayload = utf8tob64u(\n    typeof payload === \"string\" ? payload : JSON.stringify(payload)\n  );\n  const dataToSign = `${encodedHeader}.${encodedPayload}`;\n\n  const signature = await window.crypto.subtle.sign(\n    ecdsaSignAlg,\n    privateKey,\n    new TextEncoder().encode(dataToSign)\n  );\n\n  // Step 5: Encode the signature\n  const encodedSignature = hextob64u(ArrayBuffertohex(signature));\n\n  // Step 6: Concatenate the encoded parts\n  const jws = `${dataToSign}.${encodedSignature}`;\n\n  return jws;\n}\nexport async function verifyJWS(\n  jws: string,\n  pubKey?: ECDSACryptoKey<\"public\"> | JWK<\"ECDSA\", \"public\"> | null\n): Promise<boolean> {\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1);\n  }\n\n  const [header, payload, signature] = jws.split(\".\");\n  const signedData = `${header}.${payload}`;\n\n  if (!pubKey) {\n    let headerObj;\n    try {\n      headerObj = JSON.parse(b64utoutf8(header));\n    } catch (e) {\n      // ignore JSON parse errors\n    }\n    if (headerObj && \"jwk\" in headerObj && typeof headerObj.jwk === \"object\") {\n      const pubKey = await importPublicKey<\"ECDSA\">(\"ECDSA\", headerObj.jwk);\n      return verifyJWS(jws, pubKey);\n    }\n    return false;\n  }\n\n  if (\"kty\" in pubKey) {\n    pubKey = await importPublicKey(\"ECDSA\", pubKey);\n  }\n\n  const isValid = await window.crypto.subtle.verify(\n    { name: ecdsaAlg.name, hash: { name: \"SHA-384\" } },\n    pubKey as CryptoKey,\n    hextoArrayBuffer(b64utohex(signature)),\n    new TextEncoder().encode(signedData)\n  );\n  return isValid;\n}\nexport async function getJWKthumbprint<T = AlgorithmType>(\n  jwk: JWK<T, any>\n): Promise<Thumbprint<T>> {\n  invariant(jwk.kty === \"EC\", \"Unsupported key type\");\n  const s = {\n    crf: jwk.crv,\n    kty: jwk.kty,\n    x: jwk.x,\n    y: jwk.y,\n  };\n  const hex = rstrtohex(JSON.stringify(s));\n  const sha256 = await window.crypto.subtle.digest(\n    \"SHA-256\",\n    hextoArrayBuffer(hex)\n  );\n  const alg = jwk.alg ? `${jwk.alg}/` : \"\";\n\n  return `id-${alg}${hextob64u(ArrayBuffertohex(sha256))}` as any;\n}\n\nexport function exportKey<T = AlgorithmType, V = Visibility>(\n  key: TaggedKey<[T, V]>\n) {\n  return window.crypto.subtle.exportKey(\"jwk\", key) as Promise<JWK<T, V>>;\n}\n\nexport async function exportKeyPair<T = AlgorithmType>(\n  keyPair: TaggedCryptoKeyPair<T>\n) {\n  const privateKeyJWK = await exportKey(keyPair.privateKey);\n  const publicKeyJWK = await exportKey(keyPair.publicKey);\n  return { privateKeyJWK, publicKeyJWK };\n}\nexport async function encryptPrivateKey<T = AlgorithmType>(\n  privateKeyJWK: JWK<T, \"private\">,\n  password: string\n): Promise<EncryptedPrivateKey<T>> {\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"]\n  );\n\n  const salt = window.crypto.getRandomValues(new Uint8Array(16));\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const privateKeyString = JSON.stringify(privateKeyJWK);\n  const encryptedPrivateKey = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    enc.encode(privateKeyString)\n  );\n\n  return [\n    Buffer.from(encryptedPrivateKey).toString(\"base64\"),\n    Buffer.from(iv).toString(\"base64\"),\n    Buffer.from(salt).toString(\"base64\"),\n  ].join(\".\") as EncryptedPrivateKey<T>;\n}\nexport async function decryptPrivateKey<T = AlgorithmType>(\n  str: TaggedString<[T, \"private\"]>,\n  password: string\n): Promise<JWK<T, \"private\">> {\n  const [encryptedPrivateKey, iv, salt] = str\n    .split(\".\")\n    .map((b64) => Uint8Array.from(Buffer.from(b64, \"base64\")));\n  invariant(encryptedPrivateKey && iv && salt, \"Invalid encrypted private key\");\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"]\n  );\n\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n\n  const decryptedPrivateKey = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    encryptedPrivateKey\n  );\n\n  const privateKeyJWK = JSON.parse(\n    new TextDecoder().decode(decryptedPrivateKey)\n  );\n  return privateKeyJWK;\n}\nexport async function parseJWS<\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string\n>(jws: J, pubKey?: ECDSACryptoKey<\"public\"> | null) {\n  if (pubKey !== null) {\n    const isValid = await verifyJWS(jws, pubKey);\n    invariant(isValid, `JWS verification failed`);\n  }\n  return parseJWSSync(jws);\n}\nexport function parseJWSSync<\n  T extends { header: unknown; payload: unknown },\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string\n>(\n  jws: J\n): J extends SignedInvitation\n  ? Invitation\n  : J extends SignedReply\n  ? ReplyMessage\n  : J extends SignedReplyToInvite\n  ? ReplyToInvite\n  : J extends SignedSelfEncrypted\n  ? SelfEncrypted\n  : J extends SignedBackup\n  ? BackupJWS\n  : T {\n  invariant(typeof jws === \"string\", \"Expected a string\");\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1) as any;\n  }\n  const [encodedHeader, encodedPayload] = jws.split(\".\");\n  const header = JSON.parse(b64utoutf8(encodedHeader));\n  let payload = b64utoutf8(encodedPayload);\n  try {\n    payload = JSON.parse(payload);\n  } catch (e) {\n    // ignore JSON parse errors\n  }\n\n  return { header, payload } as any;\n}\n\nexport async function importPrivateKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"private\">\n): Promise<TaggedKey<[T, \"private\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"]\n  )) as TaggedKey<[T, \"private\"]>;\n}\nexport async function importPublicKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"public\">\n): Promise<TaggedKey<[T, \"public\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [] : [\"verify\"]\n  )) as TaggedKey<[T, \"public\"]>;\n}\n\nexport async function importKeyPair<T = AlgorithmType>(\n  t: {\n    privateKeyJWK: JWK<T, \"private\">;\n    publicKeyJWK: JWK<T, \"public\">;\n  },\n  type: \"ecdsa\" | \"ecdh\" = \"ecdh\"\n): Promise<{\n  privateKey: TaggedKey<[T, \"private\"]>;\n  publicKey: TaggedKey<[T, \"public\"]>;\n}> {\n  return {\n    privateKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.privateKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"]\n    )) as TaggedKey<[T, \"private\"]>,\n    publicKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.publicKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [] : [\"verify\"]\n    )) as TaggedKey<[T, \"public\"]>,\n  };\n}\n\nconst MIN_MESSAGE_SIZE = 30;\nexport async function encryptData<T extends string | object>(\n  secret: SymmetricKey,\n  message: T\n): Promise<{\n  iv: string;\n  encrypted: Encrypted<T>;\n}> {\n  try {\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    let msg = JSON.stringify({\n      m: message,\n    });\n    if (msg.length < MIN_MESSAGE_SIZE) {\n      msg = JSON.stringify({\n        random: ArrayBuffertohex(\n          window.crypto.getRandomValues(new Uint8Array(MIN_MESSAGE_SIZE / 2))\n            .buffer\n        ),\n        m: message,\n      });\n    }\n    const encrypted = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      secret,\n      new TextEncoder().encode(msg)\n    );\n    return {\n      iv: Buffer.from(iv).toString(\"base64\"),\n      encrypted: bufferToB64u(encrypted) as Encrypted<T>,\n    };\n  } catch (e: any) {\n    throw new Error(\"Failed to encrypt \" + e?.message);\n  }\n}\n\nexport async function decryptData<T extends string | object>(\n  secret: SymmetricKey,\n  iv: string,\n  encryptedPayload: Encrypted<T>\n): Promise<T> {\n  try {\n    const payloadBuffer = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: b64uToBuffer(iv),\n      },\n      secret,\n      b64uToBuffer(encryptedPayload)\n    );\n    const decoded = new TextDecoder().decode(payloadBuffer);\n    const decrypted = JSON.parse(decoded);\n\n    return (decrypted?.m ?? decrypted) as T;\n  } catch (e: any) {\n    throw new Error(\"Failed to decrypt \" + e?.message);\n  }\n}\n","import { incMessageId } from \"./index\";\n\nexport type SynAckState = {\n  syn: string | undefined;\n  minAck: string | undefined;\n  maxAck: string | undefined;\n  missing: string[];\n  windowSize: number;\n};\nexport function synAck(\n  id: { syn: string } | { ack: string },\n  state: SynAckState\n) {\n  if (\"syn\" in id) {\n    if (state.syn === undefined) {\n      state.syn = id.syn;\n    } else if (id.syn === incMessageId(state.syn)) {\n      state.syn = id.syn;\n    } else {\n      throw new Error(\n        `Syn out of order ${id.syn} - Expected: ${incMessageId(state.syn)}`\n      );\n    }\n  } else {\n    if (!state.minAck || !state.maxAck) {\n      // initialize\n      state.minAck = id.ack;\n      state.maxAck = id.ack;\n    } else if (id.ack === incMessageId(state.maxAck)) {\n      // Next expected message (max)\n      state.maxAck = id.ack;\n      if (id.ack === incMessageId(state.minAck)) {\n        // min/ax are in sync --- This is the ideal scenario\n        state.minAck = id.ack;\n      }\n    } else if (id.ack === incMessageId(state.minAck)) {\n      // Increment the minAck\n      state.minAck = id.ack;\n    } else if (id.ack <= state.minAck || id.ack === state.maxAck) {\n      // Ignore duplicate\n      return false;\n    } else if (id.ack > state.maxAck) {\n      const min = parseInt(state.minAck, 16);\n      const ack = parseInt(id.ack, 16);\n\n      if (ack - min >= state.windowSize) {\n        throw new Error(\n          `Missing ${ack - min} messages between ${state.minAck} and ${id.ack}`\n        );\n      }\n      if (state.missing.length === 0) {\n        for (let i = min + 1; i < ack; i++) {\n          state.missing.push(i.toString(16));\n        }\n      }\n      const i = state.missing.findIndex((m) => m === id.ack);\n      if (i !== -1) {\n        state.missing.splice(i, 1);\n      }\n      state.maxAck = id.ack;\n    } else {\n      throw new Error(\n        `Ack out of order ${JSON.stringify(id)} ${JSON.stringify(state)}`\n      );\n    }\n  }\n  return true;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { GridStorage, ThreadID } from \"./GridStorage\";\nimport {\n  SignedInvitation,\n  Invitation,\n  SelfEncrypted,\n  ReplyMessage,\n  SignedReply,\n  SignedBackup,\n  ReplyToInvite,\n  Decrypted,\n  SignedSelfEncrypted,\n  ReplyToInvitePayload,\n  ReplyPayload,\n  SignedTransport,\n  BackupPayload,\n} from \"./types\";\nimport {\n  generateECDSAKeyPair,\n  generateECDHKeyPair,\n  exportKeyPair,\n  encryptPrivateKey,\n  getJWKthumbprint,\n  invariant,\n  decryptPrivateKey,\n  importKeyPair,\n  parseJWS,\n  deriveSharedSecret,\n  signJWS,\n  verifyJWS,\n  JWK,\n  ECDHCryptoKeyPair,\n  ECDSACryptoKeyPair,\n  exportKey,\n  Thumbprint,\n  SymmetricKey,\n  importPrivateKey,\n  importPublicKey,\n  decryptData,\n  encryptData,\n  parseJWSSync,\n} from \"./utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\nimport { synAck } from \"./synAck\";\n\nconst keyNicknames = new Map<string, string>();\nexport function setNickname(key: string, nickname: string) {\n  keyNicknames.set(key, nickname);\n}\n\nexport function getNickname(key: string) {\n  return keyNicknames.get(key) + \"_\" + key.substring(key.length - 6);\n}\n\nlet messageIdForInviteTesting: number | undefined;\nexport function setMessageIdForTesting(messageId: number) {\n  messageIdForInviteTesting = messageId;\n}\n\nconst MAX_MESSAGE_ID = Number.MAX_SAFE_INTEGER / 2;\n\nexport type DecryptedMessageType = {\n  message: string;\n  type: \"invite\" | \"message\";\n  from: string;\n  fromThumbprint: Thumbprint<\"ECDSA\">;\n  iat: number;\n  messageId: string;\n  minAck: string | undefined;\n  epkThumbprint: Thumbprint<\"ECDH\">;\n  relay?: string;\n};\n\nexport class Client {\n  private clientNickname: string = Math.random().toString(36).slice(2);\n  async setClientNickname(nickname: string) {\n    this.clientNickname = nickname;\n    if (nickname) {\n      setNickname(this.thumbprint, this.clientNickname!);\n      setNickname(\n        await getJWKthumbprint(await exportKey(this.storageKeyPair.publicKey)),\n        `storage[${this.clientNickname!}]`\n      );\n    }\n  }\n\n  constructor(\n    private storage: GridStorage,\n    public readonly thumbprint: Thumbprint<\"ECDSA\">,\n    private readonly identityKeyPair: ECDSACryptoKeyPair,\n    private readonly storageKeyPair: ECDHCryptoKeyPair\n  ) {}\n\n  static async generateClient(\n    storage: GridStorage,\n    password: string\n  ): Promise<Client> {\n    const identity = await generateECDSAKeyPair();\n    const storageKey = await generateECDHKeyPair();\n    const idJWKs = await exportKeyPair(identity);\n    const storageJWKs = await exportKeyPair(storageKey);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n\n    const thumbprint = await getJWKthumbprint(idJWKs.publicKeyJWK);\n\n    storage.setItem(`identity:${thumbprint}`, {\n      id: {\n        jwk: idJWKs.publicKeyJWK,\n        private: encryptedIdentity,\n      },\n      storage: {\n        jwk: storageJWKs.publicKeyJWK,\n        private: encryptedStorageKey,\n      },\n    });\n\n    return Client.loadClient(storage, thumbprint, password);\n  }\n\n  static async loadFromBackup(\n    storage: GridStorage,\n    backup: BackupPayload | SignedBackup,\n    password: string\n  ): Promise<Client> {\n    if (typeof backup === \"string\") {\n      const jws = await parseJWS(backup);\n      return Client.loadFromBackup(storage, jws.payload, password);\n    }\n\n    const identityPrivateKey = await decryptPrivateKey(\n      backup.identity.id.private,\n      password\n    );\n    const storagePrivateKey = await decryptPrivateKey(\n      backup.identity.storage.private,\n      password\n    );\n\n    const identityKeyPair: ECDSACryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: identityPrivateKey,\n        publicKeyJWK: backup.identity.id.jwk,\n      },\n      \"ecdsa\"\n    );\n    const storageKeyPair: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: storagePrivateKey,\n        publicKeyJWK: backup.identity.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    await storage.loadIdentityBackup(backup);\n    const client = new Client(\n      storage,\n      backup.thumbprint,\n      identityKeyPair,\n      storageKeyPair\n    );\n    return client;\n  }\n\n  static async loadClient(\n    storage: GridStorage,\n    thumbprint: Thumbprint<\"ECDSA\">,\n    password: string\n  ) {\n    const storedData = storage.getItem(`identity:${thumbprint}`);\n    invariant(storedData, \"No identity found for thumbprint\");\n\n    const privateKeyJWK = await decryptPrivateKey(\n      storedData.id.private,\n      password\n    );\n    const id = await importKeyPair(\n      { privateKeyJWK, publicKeyJWK: storedData.id.jwk },\n      \"ecdsa\"\n    );\n\n    const storageKeys: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: await decryptPrivateKey(\n          storedData.storage.private,\n          password\n        ),\n        publicKeyJWK: storedData.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    return new Client(storage, thumbprint, id, storageKeys);\n  }\n\n  async decryptFromSelf(message: SignedSelfEncrypted): Promise<string> {\n    const selfEncrypted = await parseJWS(\n      message,\n      this.identityKeyPair.publicKey\n    );\n\n    const epk = await importPublicKey(\"ECDH\", selfEncrypted.header.epk);\n\n    const secret = await deriveSharedSecret(\n      this.storageKeyPair.privateKey,\n      epk\n    );\n    const payload = await decryptData(\n      secret,\n      selfEncrypted.header.iv,\n      selfEncrypted.payload\n    );\n    return payload;\n  }\n  async encryptToSelf(message: string) {\n    const epk = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(epk);\n\n    const secret = await deriveSharedSecret(\n      epk.privateKey,\n      this.storageKeyPair.publicKey\n    );\n    const { iv, encrypted } = await encryptData(secret, message);\n\n    const selfEncrypted: SelfEncrypted = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"self-encrypted\",\n        iv,\n        epk: jwks.publicKeyJWK,\n      },\n      payload: encrypted,\n    };\n\n    const encryptedJWS = (await signJWS(\n      selfEncrypted.header,\n      selfEncrypted.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedSelfEncrypted;\n    // try {\n    invariant(await verifyJWS(encryptedJWS), \"Error encrypting message\");\n    const decryptedMessage = await this.decryptFromSelf(encryptedJWS);\n    invariant(decryptedMessage, \"Decrypted message is empty\");\n    invariant(\n      decryptedMessage === message ||\n        message === JSON.stringify(decryptedMessage),\n      \"Decrypted message mismatch\"\n    );\n    // } catch (e: any) {\n    //   throw new Error(`Error encrypting message: ${e?.message ?? e}`);\n    // }\n\n    return encryptedJWS;\n  }\n\n  async createInvitation({\n    note,\n    nickname,\n  }: {\n    note?: string;\n    nickname: string;\n  }): Promise<SignedInvitation> {\n    const { thumbprint, jwks } = await this.makeThreadKeys();\n\n    const invitation: Invitation = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"grid-invitation\",\n      },\n      payload: {\n        messageId: Number(\n          messageIdForInviteTesting ??\n            Math.floor(Math.random() * MAX_MESSAGE_ID)\n        ).toString(16),\n        epk: jwks.publicKeyJWK,\n        note,\n        nickname,\n      },\n    };\n    const signedInvitation = (await signJWS(\n      invitation.header,\n      invitation.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedInvitation;\n\n    this.storage.setItem(`invitation:${thumbprint}`, signedInvitation);\n    this.storage.appendItem(`invitations:${this.thumbprint}`, thumbprint, {\n      unique: true,\n    });\n    this.storage.setItem(\n      `threads:${this.thumbprint}`,\n      this.storage.queryItem(`threads:${this.thumbprint}`) ?? []\n    );\n    this.notifySubscribers();\n    return signedInvitation;\n  }\n\n  async replyToInvitation(\n    signedInvite: SignedInvitation,\n    message: string,\n    nickname: string,\n    { setMyRelay }: { setMyRelay?: string } = {}\n  ) {\n    invariant(await verifyJWS(signedInvite), \"Invalid invitation signature\");\n    const invite = await parseJWS(signedInvite);\n\n    const threadId = await this.startThread(\n      signedInvite,\n      invite.payload.epk,\n      invite.header.jwk\n    );\n    const reply = this.replyToThread(threadId, message, {\n      selfSign: true,\n      nickname,\n      setMyRelay,\n    });\n    return reply;\n  }\n\n  private async startThread(\n    signedInvite: SignedInvitation,\n    theirEPKJWK: JWK<\"ECDH\", \"public\">,\n    theirSignature: JWK<\"ECDSA\", \"public\">,\n    myThumbprint?: Thumbprint<\"ECDH\">\n  ): Promise<ThreadID> {\n    if (!myThumbprint) {\n      const { thumbprint } = await this.makeThreadKeys();\n      myThumbprint = thumbprint;\n    }\n    const keyBackup = this.storage.getItem(\n      `encrypted-thread-key:${myThumbprint}`\n    );\n    invariant(keyBackup, `Thread key not found ${myThumbprint}`);\n\n    const signatureThumbprint = await getJWKthumbprint(theirSignature);\n    invariant(\n      !myThumbprint || signatureThumbprint !== this.thumbprint,\n      \"Cannot start a thread with yourself\"\n    );\n\n    const thumbprints: Thumbprint<\"ECDH\">[] = [\n      await getJWKthumbprint(theirEPKJWK),\n      myThumbprint,\n    ].sort();\n\n    const threadId = ArrayBuffertohex(\n      await window.crypto.subtle.digest(\n        \"SHA-256\",\n        Buffer.from(thumbprints.join(\":\"))\n      )\n    ) as ThreadID;\n\n    this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, {\n      missing: [],\n      windowSize: 5,\n      maxAck: undefined,\n      minAck: undefined,\n      syn: undefined,\n      myThumbprint,\n      theirEPK: theirEPKJWK,\n      signedInvite,\n      theirSignature,\n      relays: {},\n    });\n    this.storage.appendItem(`threads:${this.thumbprint}`, threadId);\n    await this.appendThread(signedInvite, threadId);\n\n    this.notifySubscribers();\n\n    return threadId;\n  }\n\n  getThreads = (): ThreadID[] =>\n    this.storage.queryItem(`threads:${this.thumbprint}`) ?? [];\n  getInvitationIds = () =>\n    this.storage.queryItem(`invitations:${this.thumbprint}`) ?? [];\n  getInvitations = () =>\n    this.getInvitationIds().map(\n      (t) => this.storage.getItem(`invitation:${t}`)!\n    );\n\n  getInvitation(thumbprint: Thumbprint<\"ECDH\">) {\n    return this.storage.getItem(`invitation:${thumbprint}`);\n  }\n\n  private async makeThreadKeys() {\n    const threadKey = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(threadKey);\n    const thumbprint = await getJWKthumbprint(jwks.publicKeyJWK);\n    setNickname(thumbprint, `thread[${this.clientNickname}]`);\n    const keyBackup = await this.encryptToSelf(JSON.stringify(jwks));\n    this.storage.setItem(`encrypted-thread-key:${thumbprint}`, keyBackup);\n\n    return { thumbprint, jwks };\n  }\n\n  private async readThreadSecret(threadThumbprint: ThreadID): Promise<{\n    secret: SymmetricKey;\n    epk: JWK<\"ECDH\", \"public\">;\n  }> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadThumbprint}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n\n    const publicJWK = threadInfo.theirEPK;\n    invariant(publicJWK, `Public key not found ${threadInfo.theirEPK}`);\n\n    const encryptedBackup = this.storage.getItem(\n      `encrypted-thread-key:${threadInfo.myThumbprint}`\n    );\n    invariant(\n      typeof encryptedBackup === \"string\",\n      `Thread key not found ${threadInfo.myThumbprint}`\n    );\n\n    type JWKPair = {\n      privateKeyJWK: JWK<\"ECDH\", \"private\">;\n      publicKeyJWK: JWK<\"ECDH\", \"public\">;\n    };\n    const jwks: JWKPair = JSON.parse(\n      await this.decryptFromSelf(encryptedBackup)\n    );\n    const pKey = await importPublicKey(\"ECDH\", publicJWK);\n    const privateKey = await importPrivateKey(\"ECDH\", jwks.privateKeyJWK);\n\n    return {\n      secret: await deriveSharedSecret(privateKey, pKey),\n      epk: jwks.publicKeyJWK,\n    };\n  }\n\n  public async replyToThread(\n    threadId: ThreadID,\n    message: string,\n    options?: {\n      selfSign?: boolean;\n      nickname?: string;\n      setMyRelay?: string;\n    }\n  ): Promise<{\n    reply: SignedReply;\n    threadId: ThreadID;\n    relay?: string;\n  }> {\n    const { secret, epk } = await this.readThreadSecret(threadId);\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const messageId =\n      threadInfo.syn ??\n      Number(\n        messageIdForInviteTesting\n          ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n          : Math.floor(Math.random() * MAX_MESSAGE_ID)\n      ).toString(16);\n    invariant(typeof messageId === \"string\", `Invalid message id ${messageId}`);\n    const nextId = incMessageId(messageId);\n    if (options?.setMyRelay) {\n      threadInfo.relays[this.thumbprint] = options.setMyRelay;\n    }\n\n    invariant(threadInfo.minAck, `Missing minAck in \"thread-info\" ${message}`);\n    let replyMessage: Decrypted<ReplyMessage | ReplyToInvite> = {\n      header: {\n        iat: 0,\n        alg: \"ES384\",\n        sub: \"grid-reply\",\n        re: threadId,\n        iv: \"\",\n        from: this.thumbprint,\n      },\n      payload: {\n        messageId: nextId,\n        message,\n        minAck: threadInfo.minAck,\n      },\n    };\n    // threadInfo.syn = nextId;\n    this.storage.setItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n      threadInfo\n    );\n    if (options?.selfSign && options.nickname) {\n      const ack: Decrypted<ReplyToInvite> = {\n        header: {\n          ...replyMessage.header,\n          sub: \"reply-to-invite\",\n          jwk: await exportKey(this.identityKeyPair.publicKey),\n          invite: await getJWKthumbprint(threadInfo.theirEPK),\n          epk,\n        },\n        payload: {\n          ...replyMessage.payload,\n          nickname: options.nickname,\n          messageId: Number(\n            messageIdForInviteTesting\n              ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n              : Math.floor(Math.random() * MAX_MESSAGE_ID)\n          ).toString(16),\n        },\n      };\n      replyMessage = ack;\n    }\n    if (options?.setMyRelay) {\n      replyMessage.payload.relay = options.setMyRelay;\n    }\n\n    const { iv, encrypted } = await encryptData(secret, replyMessage.payload);\n    replyMessage.header.iv = iv;\n    const encryptedJWS = (await signJWS(\n      replyMessage.header,\n      encrypted,\n      this.identityKeyPair.privateKey\n    )) as SignedReply;\n\n    invariant(\n      verifyJWS(encryptedJWS, this.identityKeyPair.publicKey),\n      \"Error encrypting message\"\n    );\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const relay = threadInfo.relays[theirThumbprint];\n\n    await this.appendThread(encryptedJWS, threadId);\n    return {\n      reply: encryptedJWS,\n      threadId,\n      relay,\n    };\n  }\n\n  public async appendThread(\n    encryptedMessage: SignedTransport,\n    threadId?: ThreadID\n  ): Promise<{\n    threadId: ThreadID;\n    message: {\n      message: string;\n      type: \"invite\" | \"message\";\n    };\n    relay?: string;\n  }> {\n    const jws = parseJWSSync(encryptedMessage);\n    if (!threadId) {\n      switch (jws.header.sub) {\n        case \"grid-invitation\": {\n          // const invite = jws as Invitation;\n          throw new Error(\"Not Implemented\");\n          break;\n        }\n        case \"reply-to-invite\": {\n          const isValid = verifyJWS(encryptedMessage);\n          invariant(isValid, \"Expected a self-signed message\");\n          const reply = jws as ReplyToInvite;\n          invariant(reply.header.epk, \"First message must have an epk\");\n          invariant(\n            reply.header.invite,\n            'First message must have an \"invite\" header'\n          );\n          const invitationThumbprint = reply.header.invite;\n          const invitation = this.storage.getItem(\n            `invitation:${invitationThumbprint}`\n          );\n          invariant(invitation, \"Invitation not found \" + invitationThumbprint);\n          const invitationJWS = await parseJWS(invitation);\n\n          const myThumbprint = await getJWKthumbprint(\n            invitationJWS.payload.epk\n          );\n          threadId = await this.startThread(\n            invitation,\n            reply.header.epk,\n            reply.header.jwk,\n            myThumbprint\n          );\n          // FALLS THROUGH\n        }\n        case \"grid-reply\": {\n          const reply = jws as ReplyMessage;\n          threadId ??= reply.header.re;\n          const threadInfo = this.storage.getItem(\n            `thread-info:${this.thumbprint}:${threadId}`\n          );\n\n          const fromMe = reply.header.from === this.thumbprint;\n          let isValid = false;\n          if (fromMe) {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              this.identityKeyPair.publicKey\n            );\n          } else {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              threadInfo.theirSignature\n            );\n          }\n          invariant(isValid, \"Invalid message signature\");\n\n          return this.appendThread(encryptedMessage, threadId);\n        }\n      }\n    }\n    invariant(threadId, \"Thread not found\");\n    const message = await this.decryptMessage(threadId, encryptedMessage);\n    const threadInfo = {\n      ...this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`),\n    };\n\n    const fromMe = message.fromThumbprint === this.thumbprint;\n\n    let isValid;\n    if (fromMe) {\n      isValid = await verifyJWS(\n        encryptedMessage,\n        this.identityKeyPair.publicKey\n      );\n    } else {\n      isValid = await verifyJWS(encryptedMessage, threadInfo.theirSignature);\n    }\n    invariant(isValid, \"Invalid message signature\");\n    const storeMessage = synAck(\n      fromMe\n        ? {\n            syn: message.messageId,\n          }\n        : {\n            ack: message.messageId,\n          },\n      threadInfo\n    );\n\n    if (storeMessage) {\n      const m = this.storage.queryItem(\n        `keyed-messages:${this.thumbprint}:${threadId}`\n      )?.messages;\n      invariant(\n        m ? !m.includes(encryptedMessage) : true,\n        // m?.[0] !== encryptedMessage || lastMessage !== encryptedMessage,\n        `Message already exists in thread ${JSON.stringify(\n          {\n            nickname: this.clientNickname,\n            messageId: message.messageId,\n            sub: jws.header.sub,\n            threadId,\n            messageIndex: m?.indexOf(encryptedMessage),\n          },\n          null,\n          2\n        )}`\n      );\n      if (message.relay) {\n        threadInfo.relays[await getJWKthumbprint(threadInfo.theirSignature)] =\n          message.relay;\n\n        if (\n          message.relay &&\n          message.relay.match(/^https?:\\/\\/ntfy.sh\\/[^.]+$/)\n        ) {\n          threadInfo.relays[this.thumbprint] = message.relay;\n        }\n      }\n      this.storage.setItem(\n        `thread-info:${this.thumbprint}:${threadId}`,\n        threadInfo\n      );\n      this.storage.storeMessage(\n        this.thumbprint,\n        threadId,\n        message.messageId,\n        encryptedMessage\n      );\n      this.notifySubscribers();\n    } else {\n      console.warn(\"Skipping message\", message.messageId);\n    }\n    return {\n      threadId: threadId,\n      message,\n      relay: message.relay,\n    };\n  }\n\n  public async decryptThread(threadId: ThreadID) {\n    const thread = this.getEncryptedThread(threadId);\n    const messages = await Promise.all(\n      thread.map(async (message) => {\n        return typeof message === \"string\"\n          ? this.decryptMessage(threadId, message)\n          : message;\n      })\n    );\n    messages.sort((a, b) => {\n      if (a.from !== b.from) {\n        if (a.minAck && a.minAck < b.messageId) {\n          return 1;\n        }\n        if (b.minAck && b.minAck < a.messageId) {\n          return 1;\n        }\n      }\n      const order =\n        (a.type === \"invite\" ? -1 : 0) ||\n        (b.type === \"invite\" ? 1 : 0) ||\n        b.iat - a.iat ||\n        (a.from === b.from ? a.messageId.localeCompare(b.messageId) : 0);\n\n      return order;\n    });\n    return messages;\n  }\n  public async decryptMessage(\n    threadId: ThreadID,\n    encryptedMessage: SignedTransport\n  ): Promise<DecryptedMessageType> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    const jws = await parseJWS(encryptedMessage, null);\n    invariant(threadInfo, \"Thread not found\");\n\n    if (jws.header.sub === \"grid-invitation\") {\n      // Looks like an Invite\n      invariant(await verifyJWS(encryptedMessage), \"Invalid message signature\");\n      const jwsInvite: Invitation = jws as Invitation;\n\n      const message = `Invite from ${jwsInvite.payload.nickname}.\\nNote: ${\n        jwsInvite.payload.note ?? \"(none)\"\n      }`;\n\n      const from = await getJWKthumbprint(jwsInvite.header.jwk);\n      if (jwsInvite.payload.nickname) {\n        setNickname(from, jwsInvite.payload.nickname);\n      }\n      return {\n        from: getNickname(from),\n        fromThumbprint: from,\n        epkThumbprint: await getJWKthumbprint(jwsInvite.payload.epk),\n        message,\n        type: \"invite\",\n        iat: jwsInvite.header.iat,\n        messageId: jwsInvite.payload.messageId,\n        minAck: undefined,\n      };\n    }\n    const reply = jws as ReplyMessage | ReplyToInvite;\n    const { secret } = await this.readThreadSecret(threadId);\n    const payload = await decryptData<ReplyToInvitePayload | ReplyPayload>(\n      secret,\n      jws.header.iv,\n      reply.payload\n    );\n    const from = reply.header.from;\n\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const epkThumbprint =\n      from === theirThumbprint\n        ? await getJWKthumbprint(threadInfo.theirEPK)\n        : threadInfo.myThumbprint;\n\n    return {\n      from: getNickname(from),\n      fromThumbprint: from,\n      epkThumbprint,\n      message: payload.message,\n      type: \"message\",\n      iat: reply.header.iat,\n      messageId: payload.messageId,\n      minAck: payload.minAck,\n      relay: payload.relay,\n    };\n  }\n\n  public getEncryptedThread(threadId: ThreadID) {\n    return this.storage.readMessages(this.thumbprint, threadId);\n  }\n\n  public async getThreadInfo(thread: ThreadID) {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${thread}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const myRelay = threadInfo.relays[this.thumbprint];\n\n    return {\n      myRelay,\n      myNickname: getNickname(this.thumbprint),\n      theirNickname: getNickname(\n        await getJWKthumbprint(threadInfo.theirSignature)\n      ),\n    };\n  }\n\n  async makeBackup(password: string) {\n    const idJWKs = await exportKeyPair(this.identityKeyPair);\n    const storageJWKs = await exportKeyPair(this.storageKeyPair);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n    const payload = await this.storage.makeIdentityBackup(\n      this.thumbprint,\n      encryptedIdentity,\n      encryptedStorageKey\n    );\n\n    return signJWS(\n      {\n        alg: \"ES384\",\n        jwk: idJWKs.publicKeyJWK,\n      },\n      payload,\n      this.identityKeyPair.privateKey\n    ) as Promise<SignedBackup>;\n  }\n\n  private notifySubscribers() {\n    for (const sub of this.subscriptions) {\n      sub();\n    }\n  }\n  private subscriptions = new Set<() => void>();\n  public subscribe(onChange: () => void) {\n    this.subscriptions ??= new Set<() => void>();\n    this.subscriptions.add(onChange);\n\n    return () => {\n      this.subscriptions.delete(onChange);\n    };\n  }\n}\n\nexport function incMessageId(messageId: string) {\n  let nextId = parseInt(messageId, 16) + 1;\n  if (nextId >= MAX_MESSAGE_ID) {\n    nextId = 1;\n  }\n  invariant(!Number.isNaN(nextId), `Invalid message id ${messageId} ${nextId}`);\n  const n = nextId.toString(16);\n  invariant(\n    !Number.isNaN(n),\n    `Invalid message toString ${messageId} ${nextId}`\n  );\n  return n;\n}\n\nexport { Thumbprint };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  BackupPayload,\n  SignedInvitation,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n  ThreadInfoData,\n} from \"./types\";\nimport { EncryptedPrivateKey, invariant, JWK, Thumbprint } from \"./utils\";\n\nexport type ThreadID = TaggedString<\"ThreadID\">;\n\ntype Key<Type extends StoredDataTypes[\"type\"]> = `${Type}:${Extract<\n  StoredDataTypes,\n  { type: Type }\n>[\"keyType\"]}`;\nexport type GridStorageType = {\n  hasItem<Type extends StoredDataTypes[\"type\"]>(key: Key<Type>): boolean;\n  removeItem: <Type extends StoredDataTypes[\"type\"]>(key: Key<Type>) => null;\n  queryItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"] | null;\n  getItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"];\n  setItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>,\n    value: Extract<StoredDataTypes, { type: Type }>[\"data\"]\n  ) => void;\n  appendItem: <\n    Type extends StoredDataTypes[\"type\"],\n    V extends Extract<StoredDataTypes, { type: Type }>[\"data\"]\n  >(\n    key: Key<Type>,\n    value: V extends Array<any> ? V[number] : never,\n    options?: { unique?: boolean }\n  ) => void;\n};\nexport type StoredIdentity = {\n  id: {\n    jwk: JWK<\"ECDSA\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDSA\">;\n  };\n  storage: {\n    jwk: JWK<\"ECDH\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDH\">;\n  };\n};\n\ntype StoredDataTypes =\n  | {\n      type: \"identity\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: StoredIdentity;\n    }\n  | {\n      type: \"thread-info\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: ThreadInfoData;\n    }\n  | { type: \"invitation\"; keyType: Thumbprint<\"ECDH\">; data: SignedInvitation }\n  | {\n      type: \"invitations\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: Thumbprint<\"ECDH\">[];\n    }\n  | {\n      type: \"keyed-messages\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: {\n        min: string;\n        max: string;\n        messages: Array<SignedTransport>;\n      };\n    }\n  | {\n      type: \"encrypted-thread-key\";\n      keyType: Thumbprint<\"ECDH\">;\n      data: SignedSelfEncrypted;\n    }\n  | { type: \"threads\"; keyType: Thumbprint<\"ECDSA\">; data: Array<ThreadID> };\n\nexport class GridStorage implements GridStorageType {\n  protected data: {\n    get: (key: string) => any;\n    has: (key: string) => boolean;\n    delete: (key: string) => void;\n    set: (key: string, value: any) => void;\n  } = new Map<string, any>();\n\n  debugData() {\n    return Object.fromEntries((this.data as any).entries());\n  }\n\n  async loadIdentityBackup(backup: BackupPayload) {\n    this.setItem(`identity:${backup.thumbprint}`, backup.identity);\n    Object.entries(backup.invites ?? {}).forEach(([key, value]) => {\n      this.appendItem(\n        `invitations:${backup.thumbprint}`,\n        key as Thumbprint<\"ECDH\">,\n        { unique: true }\n      );\n      this.setItem(`invitation:${key as Thumbprint<\"ECDH\">}`, value);\n    });\n    Object.entries(backup.encryptedThreadKeys).forEach(([thumbprint, key]) => {\n      this.setItem(\n        `encrypted-thread-key:${thumbprint as Thumbprint<\"ECDH\">}`,\n        key\n      );\n    });\n    Object.entries(backup.threads).forEach(([id, thread]) => {\n      const threadId = id as ThreadID;\n      this.appendItem(`threads:${backup.thumbprint}`, threadId);\n      this.setItem(\n        `thread-info:${backup.thumbprint}:${threadId}`,\n        thread.threadInfo\n      );\n      this.setItem(\n        `keyed-messages:${backup.thumbprint}:${threadId}`,\n        thread.messages\n      );\n    });\n  }\n\n  async makeIdentityBackup(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    idPrivateKey: EncryptedPrivateKey<\"ECDSA\">,\n    storagePrivateKey: EncryptedPrivateKey<\"ECDH\">\n  ): Promise<BackupPayload> {\n    const identity = this.getItem(`identity:${thumbprint}`);\n    const encryptedThreadKeys: BackupPayload[\"encryptedThreadKeys\"] = {};\n\n    return {\n      thumbprint,\n      identity: {\n        id: {\n          jwk: identity.id.jwk,\n          private: idPrivateKey,\n        },\n        storage: {\n          jwk: identity.storage.jwk,\n          private: storagePrivateKey,\n        },\n      },\n      invites: this.queryItem(`invitations:${thumbprint}`)?.reduce(\n        (memo, key) => {\n          memo[key] = this.getItem(`invitation:${key}`);\n\n          encryptedThreadKeys[key] = this.getItem(\n            `encrypted-thread-key:${key}`\n          );\n          return memo;\n        },\n        {} as NonNullable<BackupPayload[\"invites\"]>\n      ),\n      threads:\n        (await this.queryItem(`threads:${thumbprint}`)?.reduce(\n          async (m, key) => {\n            const memo = await m;\n            const threadInfo = this.getItem(`thread-info:${thumbprint}:${key}`);\n            const messages = this.getItem(\n              `keyed-messages:${thumbprint}:${key}`\n            );\n            encryptedThreadKeys[threadInfo.myThumbprint] = this.getItem(\n              `encrypted-thread-key:${threadInfo.myThumbprint}`\n            );\n\n            memo[key] = {\n              threadInfo,\n              messages,\n            };\n            return memo;\n          },\n          Promise.resolve({} as NonNullable<BackupPayload[\"threads\"]>)\n        )) ?? {},\n\n      encryptedThreadKeys,\n    };\n  }\n\n  hasItem: GridStorageType[\"hasItem\"] = (key) => {\n    return this.data.has(key);\n  };\n\n  removeItem: GridStorageType[\"removeItem\"] = (key) => {\n    this.data.delete(key);\n    return null;\n  };\n\n  queryItem: GridStorageType[\"queryItem\"] = (key) => {\n    return this.data.get(key);\n  };\n\n  getItem: GridStorageType[\"getItem\"] = (key) => {\n    invariant(this.hasItem(key), `Key ${key} not found in storage.`);\n    return this.data.get(key);\n  };\n\n  setItem: GridStorageType[\"setItem\"] = (key, value) => {\n    this.data.set(key, value);\n  };\n\n  appendItem: GridStorageType[\"appendItem\"] = (\n    key,\n    value,\n    { unique = false } = {}\n  ) => {\n    let arr: any = this.queryItem(key);\n    if (!Array.isArray(arr)) {\n      arr = [];\n    }\n    if (unique && arr.includes(value)) {\n      return;\n    }\n    arr.push(value);\n    this.setItem(key, arr);\n  };\n\n  public storeMessage(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    threadId: ThreadID,\n    messageId: string,\n    message: SignedTransport\n  ) {\n    const index = this.queryItem(\n      `keyed-messages:${thumbprint}:${threadId}`\n    ) ?? {\n      min: messageId,\n      max: messageId,\n      messages: [] as SignedTransport[],\n    };\n    index.messages.push(message);\n    this.setItem(`keyed-messages:${thumbprint}:${threadId}`, index);\n  }\n  public readMessages(thumbprint: Thumbprint<\"ECDSA\">, threadId: ThreadID) {\n    const { messages } = this.getItem(\n      `keyed-messages:${thumbprint}:${threadId}`\n    );\n    return messages;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { editor, input, select, confirm } from \"@inquirer/prompts\";\nimport { Client } from \"../client\";\nimport { ThreadID } from \"../client/GridStorage\";\nimport { displayRawMessage } from \"./mainClientMenu\";\nimport { SignedTransport } from \"../client/types\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\n\nexport async function viewEncryptedThread(client: Client, threadId: ThreadID) {\n  const thread = await client.decryptThread(threadId);\n  const threadInfo = await client.getThreadInfo(threadId);\n\n  if (threadInfo.myRelay) {\n    let json;\n    try {\n      console.log(`fetching updates from... ${threadInfo.myRelay}`);\n      const response = await fetch(\n        `${threadInfo.myRelay}/json?since=all&poll=1`\n      );\n      const text = await response.text();\n\n      await text\n        .trim()\n        .split(\"\\n\")\n        .reduce(async (p, line) => {\n          await p;\n          json = JSON.parse(line);\n          if (json?.message) {\n            await client.appendThread(json.message, threadId).catch(() => {\n              // Ignore errors about duplicate messages. This is expected.\n            });\n          }\n        }, Promise.resolve());\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  console.log(\n    `Thread: ${threadId}\\n--------------------------------------------`\n  );\n  thread.map((message) => {\n    console.log(\n      `${message.type} From: ${message.from} ${new Date(message.iat * 1000)}\\n${\n        message.message\n      }\\n--------------------------------------------`\n    );\n  });\n\n  const selection = await select({\n    message: \"What would you like to do?\",\n    choices: [\n      threadInfo.myRelay ? { name: \"Refresh\", value: \"refresh\" } : null,\n      { name: \"Reply\", value: \"reply\" },\n      { name: \"Reply (in $EDITOR)\", value: \"replyEditor\" },\n      { name: \"Paste encrypted message\", value: \"paste\" },\n      { name: \"View message details\", value: \"viewDetils\" },\n      {\n        name: threadInfo.myRelay ? \"Change Relay\" : \"Set Relay\",\n        value: \"setRelay\",\n      },\n      { name: \"Back to main menu\", value: \"back\" },\n    ].filter((n) => n != null),\n  });\n\n  switch (selection) {\n    case \"back\":\n      return;\n    case \"setRelay\": {\n      let message =\n        \"Are you sure you want to remove your relay? The operation takes effect while sending a message\";\n      let newRelayUrl = \"\";\n      if (!threadInfo.myRelay) {\n        const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n        newRelayUrl = `https://ntfy.sh/${ArrayBuffertohex(topicArray.buffer)}`;\n        message = `Use ${newRelayUrl} to send future messages? The operation takes effect while sending a message`;\n      }\n\n      if (await confirm({ message })) {\n        const selection = await select({\n          message: \"What would you like to do?\",\n          choices: [\n            { name: \"Reply\", value: \"reply\" },\n            { name: \"Reply (in $EDITOR)\", value: \"replyEditor\" },\n            { name: \"Back to main menu\", value: \"back\" },\n          ],\n        });\n        if (selection === \"reply\" || selection === \"replyEditor\") {\n          await replyMenu(client, threadId, selection, {\n            setMyRelay: newRelayUrl,\n          });\n        }\n      }\n      break;\n    }\n    case \"replyEditor\":\n    case \"reply\": {\n      await replyMenu(client, threadId, selection);\n      break;\n    }\n    case \"paste\": {\n      const message = await input({\n        required: false,\n        message:\n          \"Paste the encrypted reply you recieved (leave empty to cancel)\",\n      });\n      if (message) {\n        await client.appendThread(message as SignedTransport, threadId);\n      }\n      break;\n    }\n    case \"viewDetils\": {\n      const index = await select({\n        message: \"Which message would you like to inspect?\",\n        choices: thread.map((message, index) => ({\n          name: `From: ${message.from} ${new Date(message.iat * 1000)}\\n${\n            message.message\n          }`,\n          value: index,\n        })),\n      });\n\n      if (index >= 0) {\n        console.log(thread[index]);\n        const encrypted = client.getEncryptedThread(threadId)[index];\n        console.log(encrypted);\n      }\n    }\n  }\n\n  return viewEncryptedThread(client, threadId);\n}\n\nasync function replyMenu(\n  client: Client,\n  threadId: ThreadID,\n  variant: \"reply\" | \"replyEditor\",\n  options: { setMyRelay?: string } = {}\n) {\n  const prompt = variant === \"reply\" ? input : editor;\n  const message = await prompt({\n    required: false,\n    message: \"Enter your message. (leave empty to cancel)\",\n  });\n  if (message) {\n    const { reply, relay } = await client.replyToThread(threadId, message, {\n      setMyRelay: options.setMyRelay,\n    });\n    await displayRawMessage(reply, relay);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { input, rawlist, confirm } from \"@inquirer/prompts\";\nimport { Client, Thumbprint } from \"../client\";\nimport { ThreadID } from \"../client/GridStorage\";\nimport { SignedInvitation, SignedTransport } from \"../client/types\";\nimport { viewEncryptedThread } from \"./viewEncryptedThread\";\nimport { verifyJWS, parseJWSSync, getJWKthumbprint } from \"../client/utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\n\nexport async function mainClientMenu(client: Client) {\n  const invitations = client.getInvitationIds();\n  const threads = client.getThreads();\n\n  type Selection =\n    | \"exit\"\n    | \"createInvitation\"\n    | \"replyToInvitation\"\n    | ThreadID\n    | Thumbprint<\"ECDH\">;\n  console.clear();\n  const selection = await rawlist<Selection>({\n    message: \"What would you like to do?\",\n    choices: [\n      { name: \"Create Invitation\", value: \"createInvitation\" },\n      ...invitations.map((value) => ({\n        name: `View Invitation: ${value}`,\n        value: value,\n      })),\n      { name: \"Reply to Invitation\", value: \"replyToInvitation\" },\n      ...threads.map((value) => ({\n        name: `View Thread: ${value}`,\n        value: value,\n      })),\n      {\n        name: \"Exit\",\n        value: \"exit\",\n      },\n    ],\n  });\n\n  if (selection === \"exit\") {\n    process.exit(0);\n  } else if (selection === \"createInvitation\") {\n    await createInvitationMenu(client);\n  } else if (selection === \"replyToInvitation\") {\n    await replyToInvitationMenu(client);\n  }\n\n  if (threads.includes(selection as ThreadID)) {\n    await viewEncryptedThread(client, selection as ThreadID);\n  }\n  if (invitations.includes(selection as Thumbprint<\"ECDH\">)) {\n    const invitation = client.getInvitation(selection as Thumbprint<\"ECDH\">);\n    console.log(invitation);\n    const reply = await input({\n      required: false,\n      message:\n        \"If you have received a reply, paste it here, or leave this empty to continue to the main menu\",\n    });\n    if (reply) {\n      const { threadId } = await client.appendThread(reply as SignedTransport);\n      await viewEncryptedThread(client, threadId);\n    }\n  }\n}\n\nasync function createInvitationMenu(client: Client) {\n  const nickname = await input({\n    message: \"What would you like your nickname to be in this conversation?\",\n  });\n  const note = await input({\n    required: false,\n    message: \"(optional) Note to include with the invitation\",\n  });\n\n  const invite = await client.createInvitation({ note, nickname });\n\n  console.log(\n    `Invitation created. Share the text below to allow friends to encrypt messages to you.`\n  );\n  console.log(invite);\n  console.log(\"\\n\\n\\n\");\n}\n\nasync function replyToInvitationMenu(client: Client) {\n  const invite = await input({\n    message: \"Paste the invitation here\",\n  });\n  if (!invite) return;\n  const isValid = await verifyJWS(invite);\n  if (!isValid) {\n    console.log(\"Invalid invite\");\n    return;\n  }\n\n  const jws = parseJWSSync(invite as SignedInvitation);\n  const thumbprint = await getJWKthumbprint(jws.payload.epk);\n\n  console.log(`Invitation Thumbprint: ${thumbprint}`);\n  console.log(`Nickname: ${jws.payload.nickname}`);\n  console.log(`Note: ${jws.payload.note}`);\n\n  const nickname = await input({\n    message: \"What would you like your nickname to be in this conversation?\",\n    required: true,\n  });\n  let setMyRelay = undefined;\n  const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n  const newRelayUrl = `https://ntfy.sh/${ArrayBuffertohex(topicArray.buffer)}`;\n  const message = `Use ${newRelayUrl} to send future messages?`;\n  if (await confirm({ message })) {\n    setMyRelay = newRelayUrl;\n  }\n\n  const reply = await input({\n    required: false,\n    message: \"Enter your reply, or leave empty to cancel\",\n  });\n  if (reply) {\n    const {\n      threadId,\n      reply: message,\n      relay,\n    } = await client.replyToInvitation(\n      invite as SignedInvitation,\n      reply,\n      nickname,\n      { setMyRelay }\n    );\n    await displayRawMessage(message, relay);\n    return viewEncryptedThread(client, threadId);\n  }\n}\nexport async function displayRawMessage(message: string, relay?: string) {\n  console.log(`Here is the message for you to send to the recipient`);\n  console.log(message);\n\n  if (!relay) {\n    await confirm({ message: \"Press enter to continue\" });\n  } else {\n    const sendToRelay = await confirm({\n      message: `Send message to relay? ${relay}`,\n    });\n    if (sendToRelay) {\n      await fetch(relay, {\n        method: \"POST\",\n        body: message,\n      }).catch(console.error);\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { password, rawlist, select } from \"@inquirer/prompts\";\nimport * as path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { Client } from \"../client\";\nimport { GridStorage } from \"../client/GridStorage\";\nimport { SignedBackup } from \"../client/types\";\nimport crypto from \"crypto\";\nimport debounce from \"lodash.debounce\";\nimport { mainClientMenu } from \"./mainClientMenu\";\n\nglobal.window ??= {} as any;\n// @ts-expect-error The main target of the project is browsers, so it relies on window.crypto\nwindow.crypto = crypto;\n\nasync function main() {\n  console.clear();\n  const files = await fs.readdir(\".\");\n  const jwsTxtFiles = files.filter((file) => file.endsWith(\".jws.txt\"));\n\n  if (jwsTxtFiles.length > 0) {\n    const filename = await rawlist({\n      message: \"Which file would you like to open?\",\n      choices: [\n        ...jwsTxtFiles.map((file) => ({\n          name: path.basename(file, \".jws.txt\"),\n          value: file,\n        })),\n        { value: \"newIdentity\", name: \"Create a new identity\" },\n      ],\n    });\n    if (filename === \"newIdentity\") {\n      return makeNewIdentity();\n    }\n\n    const pass = await password({\n      message: \"Enter pass phrase to decrypt file\",\n    });\n    const backup = (await fs.readFile(filename, \"utf-8\")) as SignedBackup;\n    try {\n      const client = await Client.loadFromBackup(\n        new GridStorage(),\n        backup,\n        pass\n      );\n      client.subscribe(\n        debounce(async () => {\n          const backup = await client.makeBackup(pass);\n          await fs.writeFile(filename, backup);\n        }, 500)\n      );\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        await mainClientMenu(client);\n      }\n    } catch (e) {\n      console.error(\"Error loading backup\", e);\n      process.exit(1);\n    }\n  } else {\n    const newIdentity = await select({\n      message:\n        \"No backup files found. Would you like to create a new identity?\",\n      choices: [\n        { name: \"Yes\", value: \"yes\" },\n        { name: \"No\", value: \"no\" },\n      ],\n    });\n\n    if (newIdentity === \"no\") {\n      process.exit(0);\n    }\n    return makeNewIdentity();\n  }\n}\n\nasync function makeNewIdentity() {\n  let pass1 = \"\";\n  for (let tries = 0; tries < 3; tries++) {\n    pass1 = await password({\n      message: \"Enter pass phrase to encrypt your new identity\",\n    });\n    const pass2 = await password({\n      message: \"Enter pass phrase again to confirm\",\n    });\n    if (pass1 === pass2) {\n      break;\n    }\n    console.error(\"Passwords do not match\");\n  }\n\n  const client = await Client.generateClient(new GridStorage(), pass1);\n  const filename = `grid-${client.thumbprint}.jws.txt`;\n  client.subscribe(\n    debounce(async () => {\n      const backup = await client.makeBackup(pass1);\n      await fs.writeFile(filename, backup);\n    }, 500)\n  );\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    await mainClientMenu(client);\n  }\n}\n\nmain();\n"]}
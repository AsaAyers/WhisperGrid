{"mappings":"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","sources":["src/client/src/client/synAck.ts","src/client/src/client/utils.ts","src/client/src/client/types.ts","src/client/src/client/GridStorage.ts","src/client/src/client/index.ts","src/client/index.ts"],"sourcesContent":[null,null,null,null,null,"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { GridStorage, ThreadID } from \"./GridStorage\";\nimport {\n  SignedInvitation,\n  Invitation,\n  SelfEncrypted,\n  ReplyMessage,\n  SignedReply,\n  SignedBackup,\n  ReplyToInvite,\n  Decrypted,\n  SignedSelfEncrypted,\n  ReplyToInvitePayload,\n  ReplyPayload,\n  SignedTransport,\n  BackupPayload,\n  UnpackTaggedString,\n  SignedReplyToInvite,\n} from \"./types\";\nimport {\n  generateECDSAKeyPair,\n  generateECDHKeyPair,\n  exportKeyPair,\n  encryptPrivateKey,\n  getJWKthumbprint,\n  invariant,\n  decryptPrivateKey,\n  importKeyPair,\n  parseJWS,\n  deriveSharedSecret,\n  signJWS,\n  verifyJWS,\n  JWK,\n  ECDHCryptoKeyPair,\n  ECDSACryptoKeyPair,\n  exportKey,\n  Thumbprint,\n  SymmetricKey,\n  importPrivateKey,\n  importPublicKey,\n  decryptData,\n  encryptData,\n  parseJWSSync,\n} from \"./utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\nimport { synAck } from \"./synAck\";\n\nconst keyNicknames = new Map<string, string>();\nexport function setNickname(key: string, nickname: string) {\n  keyNicknames.set(key, nickname);\n}\n\nexport function getNickname(key: string) {\n  return keyNicknames.get(key) + \"_\" + key.substring(key.length - 6);\n}\n\nlet messageIdForInviteTesting: number | undefined;\nexport function setMessageIdForTesting(messageId: number) {\n  messageIdForInviteTesting = messageId;\n}\n\nconst MAX_MESSAGE_ID = Number.MAX_SAFE_INTEGER / 2;\n\nexport type DecryptedMessageType = {\n  message: string;\n  type: \"invite\" | \"message\";\n  from: string;\n  fromThumbprint: Thumbprint<\"ECDSA\">;\n  iat: number;\n  messageId: string;\n  minAck: string | undefined;\n  epkThumbprint: Thumbprint<\"ECDH\">;\n  relay?: string;\n};\n\n/**\n * In order to use the client over a websocket connection, everything on it\n * should be async functions. They also can't be arrow functions, because the\n * proxy is looking at the prototype to figure out if there is a function to\n * call.\n */\nexport class Client {\n  public isLocalClient = true; // The proxy will override this\n  /**\n   * The proxy uses this to distinguish between a complete Client object and a\n   * RemoteSetup object.\n   */\n  public isLoggedIn = true as const;\n  private clientNickname: string = Math.random().toString(36).slice(2);\n  async setClientNickname(nickname: string) {\n    this.clientNickname = nickname;\n    if (nickname) {\n      setNickname(this.thumbprint, this.clientNickname!);\n      setNickname(\n        await getJWKthumbprint(await exportKey(this.storageKeyPair.publicKey)),\n        `storage[${this.clientNickname!}]`\n      );\n    }\n  }\n\n  constructor(\n    private storage: GridStorage,\n    private readonly thumbprint: Thumbprint<\"ECDSA\">,\n    private readonly identityKeyPair: ECDSACryptoKeyPair,\n    private readonly storageKeyPair: ECDHCryptoKeyPair\n  ) {}\n\n  async getThumbprint() {\n    return this.thumbprint;\n  }\n\n  static async generateClient(\n    storage: GridStorage,\n    password: string\n  ): Promise<Client> {\n    const identity = await generateECDSAKeyPair();\n    const storageKey = await generateECDHKeyPair();\n    const idJWKs = await exportKeyPair(identity);\n    const storageJWKs = await exportKeyPair(storageKey);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n\n    const thumbprint = await getJWKthumbprint(idJWKs.publicKeyJWK);\n\n    storage.setItem(`identity:${thumbprint}`, {\n      id: {\n        jwk: idJWKs.publicKeyJWK,\n        private: encryptedIdentity,\n      },\n      storage: {\n        jwk: storageJWKs.publicKeyJWK,\n        private: encryptedStorageKey,\n      },\n    });\n\n    return Client.loadClient(storage, thumbprint, password);\n  }\n\n  static async loadFromBackup(\n    storage: GridStorage,\n    backup: BackupPayload | SignedBackup,\n    password: string\n  ): Promise<Client> {\n    if (typeof backup === \"string\") {\n      const jws = await parseJWS(backup);\n      return Client.loadFromBackup(storage, jws.payload, password);\n    }\n\n    const identityPrivateKey = await decryptPrivateKey(\n      backup.identity.id.private,\n      password\n    );\n    const storagePrivateKey = await decryptPrivateKey(\n      backup.identity.storage.private,\n      password\n    );\n\n    const identityKeyPair: ECDSACryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: identityPrivateKey,\n        publicKeyJWK: backup.identity.id.jwk,\n      },\n      \"ecdsa\"\n    );\n    const storageKeyPair: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: storagePrivateKey,\n        publicKeyJWK: backup.identity.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    await storage.loadIdentityBackup(backup);\n    const client = new Client(\n      storage,\n      backup.thumbprint,\n      identityKeyPair,\n      storageKeyPair\n    );\n    return client;\n  }\n\n  static async loadClient(\n    storage: GridStorage,\n    thumbprint: Thumbprint<\"ECDSA\">,\n    password: string\n  ) {\n    const storedData = storage.getItem(`identity:${thumbprint}`);\n    invariant(storedData, \"No identity found for thumbprint\");\n\n    const privateKeyJWK = await decryptPrivateKey(\n      storedData.id.private,\n      password\n    );\n    const id = await importKeyPair(\n      { privateKeyJWK, publicKeyJWK: storedData.id.jwk },\n      \"ecdsa\"\n    );\n\n    const storageKeys: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: await decryptPrivateKey(\n          storedData.storage.private,\n          password\n        ),\n        publicKeyJWK: storedData.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    return new Client(storage, thumbprint, id, storageKeys);\n  }\n\n  async decryptFromSelf(message: SignedSelfEncrypted): Promise<string> {\n    const selfEncrypted = await parseJWS(\n      message,\n      this.identityKeyPair.publicKey\n    );\n\n    const epk = await importPublicKey(\"ECDH\", selfEncrypted.header.epk);\n\n    const secret = await deriveSharedSecret(\n      this.storageKeyPair.privateKey,\n      epk\n    );\n    const payload = await decryptData(\n      secret,\n      selfEncrypted.header.iv,\n      selfEncrypted.payload\n    );\n    return payload;\n  }\n  async encryptToSelf(message: string) {\n    const epk = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(epk);\n\n    const secret = await deriveSharedSecret(\n      epk.privateKey,\n      this.storageKeyPair.publicKey\n    );\n    const { iv, encrypted } = await encryptData(secret, message);\n\n    const selfEncrypted: SelfEncrypted = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"self-encrypted\",\n        iv,\n        epk: jwks.publicKeyJWK,\n      },\n      payload: encrypted,\n    };\n\n    const encryptedJWS = (await signJWS(\n      selfEncrypted.header,\n      selfEncrypted.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedSelfEncrypted;\n    // try {\n    invariant(await verifyJWS(encryptedJWS), \"Error encrypting message\");\n    const decryptedMessage = await this.decryptFromSelf(encryptedJWS);\n    invariant(decryptedMessage, \"Decrypted message is empty\");\n    invariant(\n      decryptedMessage === message ||\n        message === JSON.stringify(decryptedMessage),\n      \"Decrypted message mismatch\"\n    );\n    // } catch (e: any) {\n    //   throw new Error(`Error encrypting message: ${e?.message ?? e}`);\n    // }\n\n    return encryptedJWS;\n  }\n\n  async createInvitation({\n    note,\n    nickname,\n  }: {\n    note?: string;\n    nickname: string;\n  }): Promise<SignedInvitation> {\n    const { thumbprint, jwks } = await this.makeThreadKeys();\n\n    const invitation: Invitation = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"grid-invitation\",\n      },\n      payload: {\n        messageId: Number(\n          messageIdForInviteTesting ??\n            Math.floor(Math.random() * MAX_MESSAGE_ID)\n        ).toString(16),\n        epk: jwks.publicKeyJWK,\n        note,\n        nickname,\n      },\n    };\n    const signedInvitation = (await signJWS(\n      invitation.header,\n      invitation.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedInvitation;\n\n    this.storage.setItem(`invitation:${thumbprint}`, signedInvitation);\n    this.storage.appendItem(`invitations:${this.thumbprint}`, thumbprint, {\n      unique: true,\n    });\n    this.storage.setItem(\n      `threads:${this.thumbprint}`,\n      this.storage.queryItem(`threads:${this.thumbprint}`) ?? []\n    );\n    this.notifySubscribers();\n    return signedInvitation;\n  }\n\n  async replyToInvitation(\n    signedInvite: SignedInvitation,\n    message: string,\n    nickname: string,\n    { setMyRelay }: { setMyRelay?: string } = {}\n  ) {\n    invariant(await verifyJWS(signedInvite), \"Invalid invitation signature\");\n    const invite = await parseJWS(signedInvite);\n\n    const threadId = await this.startThread(\n      signedInvite,\n      invite.payload.epk,\n      invite.header.jwk\n    );\n    const reply = this.replyToThread(threadId, message, {\n      selfSign: true,\n      nickname,\n      setMyRelay,\n    });\n    return reply;\n  }\n\n  private async startThread(\n    signedInvite: SignedInvitation,\n    theirEPKJWK: JWK<\"ECDH\", \"public\">,\n    theirSignature: JWK<\"ECDSA\", \"public\">,\n    myThumbprint?: Thumbprint<\"ECDH\">\n  ): Promise<ThreadID> {\n    if (!myThumbprint) {\n      const { thumbprint } = await this.makeThreadKeys();\n      myThumbprint = thumbprint;\n    }\n    const keyBackup = this.storage.getItem(\n      `encrypted-thread-key:${myThumbprint}`\n    );\n    invariant(keyBackup, `Thread key not found ${myThumbprint}`);\n\n    const signatureThumbprint = await getJWKthumbprint(theirSignature);\n    invariant(\n      !myThumbprint || signatureThumbprint !== this.thumbprint,\n      \"Cannot start a thread with yourself\"\n    );\n\n    const thumbprints: Thumbprint<\"ECDH\">[] = [\n      await getJWKthumbprint(theirEPKJWK),\n      myThumbprint,\n    ].sort();\n\n    const threadId = ArrayBuffertohex(\n      await window.crypto.subtle.digest(\n        \"SHA-256\",\n        Buffer.from(thumbprints.join(\":\"))\n      )\n    ) as ThreadID;\n\n    this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, {\n      missing: [],\n      windowSize: 5,\n      maxAck: undefined,\n      minAck: undefined,\n      syn: undefined,\n      myThumbprint,\n      theirEPK: theirEPKJWK,\n      signedInvite,\n      theirSignature,\n      relays: {},\n    });\n    this.storage.appendItem(`threads:${this.thumbprint}`, threadId);\n    await this.appendThread(signedInvite, threadId);\n\n    this.notifySubscribers();\n\n    return threadId;\n  }\n\n  async getThreads(): Promise<ThreadID[]> {\n    return this.storage.queryItem(`threads:${this.thumbprint}`) ?? [];\n  }\n  async getInvitationIds() {\n    return this.storage.queryItem(`invitations:${this.thumbprint}`) ?? [];\n  }\n  async getInvitations() {\n    return (await this.getInvitationIds()).map(\n      (t) => this.storage.getItem(`invitation:${t}`)!\n    );\n  }\n\n  async getInvitation(thumbprint: Thumbprint<\"ECDH\">) {\n    return this.storage.getItem(`invitation:${thumbprint}`);\n  }\n\n  private async makeThreadKeys() {\n    const threadKey = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(threadKey);\n    const thumbprint = await getJWKthumbprint(jwks.publicKeyJWK);\n    setNickname(thumbprint, `thread[${this.clientNickname}]`);\n    const keyBackup = await this.encryptToSelf(JSON.stringify(jwks));\n    this.storage.setItem(`encrypted-thread-key:${thumbprint}`, keyBackup);\n\n    return { thumbprint, jwks };\n  }\n\n  private async readThreadSecret(threadThumbprint: ThreadID): Promise<{\n    secret: SymmetricKey;\n    epk: JWK<\"ECDH\", \"public\">;\n  }> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadThumbprint}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n\n    const publicJWK = threadInfo.theirEPK;\n    invariant(publicJWK, `Public key not found ${threadInfo.theirEPK}`);\n\n    const encryptedBackup = this.storage.getItem(\n      `encrypted-thread-key:${threadInfo.myThumbprint}`\n    );\n    invariant(\n      typeof encryptedBackup === \"string\",\n      `Thread key not found ${threadInfo.myThumbprint}`\n    );\n\n    type JWKPair = {\n      privateKeyJWK: JWK<\"ECDH\", \"private\">;\n      publicKeyJWK: JWK<\"ECDH\", \"public\">;\n    };\n    const jwks: JWKPair = JSON.parse(\n      await this.decryptFromSelf(encryptedBackup)\n    );\n    const pKey = await importPublicKey(\"ECDH\", publicJWK);\n    const privateKey = await importPrivateKey(\"ECDH\", jwks.privateKeyJWK);\n\n    return {\n      secret: await deriveSharedSecret(privateKey, pKey),\n      epk: jwks.publicKeyJWK,\n    };\n  }\n\n  public async replyToThread(\n    threadId: ThreadID,\n    message: string,\n    options?: {\n      selfSign?: boolean;\n      nickname?: string;\n      setMyRelay?: string;\n    }\n  ): Promise<{\n    reply: SignedReply;\n    threadId: ThreadID;\n    relay?: string;\n  }> {\n    const { secret, epk } = await this.readThreadSecret(threadId);\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const messageId =\n      threadInfo.syn ??\n      Number(\n        messageIdForInviteTesting\n          ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n          : Math.floor(Math.random() * MAX_MESSAGE_ID)\n      ).toString(16);\n    invariant(typeof messageId === \"string\", `Invalid message id ${messageId}`);\n    const nextId = incMessageId(messageId);\n    if (options?.setMyRelay) {\n      threadInfo.relays[this.thumbprint] = options.setMyRelay;\n    }\n\n    invariant(threadInfo.minAck, `Missing minAck in \"thread-info\" ${message}`);\n    let replyMessage: Decrypted<ReplyMessage | ReplyToInvite> = {\n      header: {\n        iat: 0,\n        alg: \"ES384\",\n        sub: \"grid-reply\",\n        re: threadId,\n        iv: \"\",\n        from: this.thumbprint,\n      },\n      payload: {\n        messageId: nextId,\n        message,\n        minAck: threadInfo.minAck,\n      },\n    };\n    // threadInfo.syn = nextId;\n    this.storage.setItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n      threadInfo\n    );\n    if (options?.selfSign && options.nickname) {\n      const ack: Decrypted<ReplyToInvite> = {\n        header: {\n          ...replyMessage.header,\n          sub: \"reply-to-invite\",\n          jwk: await exportKey(this.identityKeyPair.publicKey),\n          invite: await getJWKthumbprint(threadInfo.theirEPK),\n          epk,\n        },\n        payload: {\n          ...replyMessage.payload,\n          nickname: options.nickname,\n          messageId: Number(\n            messageIdForInviteTesting\n              ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n              : Math.floor(Math.random() * MAX_MESSAGE_ID)\n          ).toString(16),\n        },\n      };\n      replyMessage = ack;\n    }\n    if (options?.setMyRelay) {\n      replyMessage.payload.relay = options.setMyRelay;\n    }\n\n    const { iv, encrypted } = await encryptData(secret, replyMessage.payload);\n    replyMessage.header.iv = iv;\n    const encryptedJWS = (await signJWS(\n      replyMessage.header,\n      encrypted,\n      this.identityKeyPair.privateKey\n    )) as SignedReply;\n\n    invariant(\n      verifyJWS(encryptedJWS, this.identityKeyPair.publicKey),\n      \"Error encrypting message\"\n    );\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const relay = threadInfo.relays[theirThumbprint];\n\n    await this.appendThread(encryptedJWS, threadId);\n    return {\n      reply: encryptedJWS,\n      threadId,\n      relay,\n    };\n  }\n\n  public async appendThread(\n    encryptedMessage: SignedTransport,\n    threadId?: ThreadID\n  ): Promise<{\n    threadId: ThreadID;\n    message: {\n      message: string;\n      type: \"invite\" | \"message\";\n    };\n    relay?: string;\n  }> {\n    const jws = parseJWSSync(encryptedMessage);\n    if (!threadId) {\n      switch (jws.header.sub) {\n        case \"grid-invitation\": {\n          // const invite = jws as Invitation;\n          throw new Error(\"Not Implemented\");\n          break;\n        }\n        case \"reply-to-invite\": {\n          const isValid = verifyJWS(encryptedMessage);\n          invariant(isValid, \"Expected a self-signed message\");\n          const reply = jws as ReplyToInvite;\n          invariant(reply.header.epk, \"First message must have an epk\");\n          invariant(\n            reply.header.invite,\n            'First message must have an \"invite\" header'\n          );\n          const invitationThumbprint = reply.header.invite;\n          const invitation = this.storage.getItem(\n            `invitation:${invitationThumbprint}`\n          );\n          invariant(invitation, \"Invitation not found \" + invitationThumbprint);\n          const invitationJWS = await parseJWS(invitation);\n\n          const myThumbprint = await getJWKthumbprint(\n            invitationJWS.payload.epk\n          );\n          threadId = await this.startThread(\n            invitation,\n            reply.header.epk,\n            reply.header.jwk,\n            myThumbprint\n          );\n          // FALLS THROUGH\n        }\n        case \"grid-reply\": {\n          const reply = jws as ReplyMessage;\n          threadId ??= reply.header.re;\n          const threadInfo = this.storage.getItem(\n            `thread-info:${this.thumbprint}:${threadId}`\n          );\n\n          const fromMe = reply.header.from === this.thumbprint;\n          let isValid = false;\n          if (fromMe) {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              this.identityKeyPair.publicKey\n            );\n          } else {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              threadInfo.theirSignature\n            );\n          }\n          invariant(isValid, \"Invalid message signature\");\n\n          return this.appendThread(encryptedMessage, threadId);\n        }\n      }\n    }\n    invariant(threadId, \"Thread not found\");\n    const message = await this.decryptMessage(threadId, encryptedMessage);\n    const threadInfo = {\n      ...this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`),\n    };\n\n    const fromMe = message.fromThumbprint === this.thumbprint;\n\n    let isValid;\n    if (fromMe) {\n      isValid = await verifyJWS(\n        encryptedMessage,\n        this.identityKeyPair.publicKey\n      );\n    } else {\n      isValid = await verifyJWS(encryptedMessage, threadInfo.theirSignature);\n    }\n    invariant(isValid, \"Invalid message signature\");\n    const storeMessage = synAck(\n      fromMe\n        ? {\n            syn: message.messageId,\n          }\n        : {\n            ack: message.messageId,\n          },\n      threadInfo\n    );\n\n    if (storeMessage) {\n      const m = this.storage.queryItem(\n        `keyed-messages:${this.thumbprint}:${threadId}`\n      )?.messages;\n      invariant(\n        m ? !m.includes(encryptedMessage) : true,\n        // m?.[0] !== encryptedMessage || lastMessage !== encryptedMessage,\n        `Message already exists in thread ${JSON.stringify(\n          {\n            nickname: this.clientNickname,\n            messageId: message.messageId,\n            sub: jws.header.sub,\n            threadId,\n            messageIndex: m?.indexOf(encryptedMessage),\n          },\n          null,\n          2\n        )}`\n      );\n      if (message.relay) {\n        threadInfo.relays[await getJWKthumbprint(threadInfo.theirSignature)] =\n          message.relay;\n\n        if (\n          message.relay &&\n          message.relay.match(/^https?:\\/\\/ntfy.sh\\/[^.]+$/)\n        ) {\n          threadInfo.relays[this.thumbprint] = message.relay;\n        }\n      }\n      this.storage.setItem(\n        `thread-info:${this.thumbprint}:${threadId}`,\n        threadInfo\n      );\n      this.storage.storeMessage(\n        this.thumbprint,\n        threadId,\n        message.messageId,\n        encryptedMessage\n      );\n      this.notifySubscribers();\n    } else {\n      console.warn(\"Skipping message\", message.messageId);\n    }\n    return {\n      threadId: threadId,\n      message,\n      relay: message.relay,\n    };\n  }\n\n  public async decryptThread(threadId: ThreadID) {\n    const thread = await this.getEncryptedThread(threadId);\n    const messages = await Promise.all(\n      thread.map(async (message) => {\n        return typeof message === \"string\"\n          ? this.decryptMessage(threadId, message)\n          : message;\n      })\n    );\n    messages.sort((a, b) => {\n      if (a.from !== b.from) {\n        if (a.minAck && a.minAck < b.messageId) {\n          return 1;\n        }\n        if (b.minAck && b.minAck < a.messageId) {\n          return 1;\n        }\n      }\n      const order =\n        (a.type === \"invite\" ? -1 : 0) ||\n        (b.type === \"invite\" ? 1 : 0) ||\n        b.iat - a.iat ||\n        (a.from === b.from ? a.messageId.localeCompare(b.messageId) : 0);\n\n      return order;\n    });\n    return messages;\n  }\n  public async decryptMessage(\n    threadId: ThreadID,\n    encryptedMessage: SignedTransport\n  ): Promise<DecryptedMessageType> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    const jws = await parseJWS(encryptedMessage, null);\n    invariant(threadInfo, \"Thread not found\");\n\n    if (jws.header.sub === \"grid-invitation\") {\n      // Looks like an Invite\n      invariant(await verifyJWS(encryptedMessage), \"Invalid message signature\");\n      const jwsInvite: Invitation = jws as Invitation;\n\n      const message = `Invite from ${jwsInvite.payload.nickname}.\\nNote: ${\n        jwsInvite.payload.note ?? \"(none)\"\n      }`;\n\n      const from = await getJWKthumbprint(jwsInvite.header.jwk);\n      if (jwsInvite.payload.nickname) {\n        setNickname(from, jwsInvite.payload.nickname);\n      }\n      return {\n        from: getNickname(from),\n        fromThumbprint: from,\n        epkThumbprint: await getJWKthumbprint(jwsInvite.payload.epk),\n        message,\n        type: \"invite\",\n        iat: jwsInvite.header.iat,\n        messageId: jwsInvite.payload.messageId,\n        minAck: undefined,\n      };\n    }\n    const reply = jws as ReplyMessage | ReplyToInvite;\n    const { secret } = await this.readThreadSecret(threadId);\n    const payload = await decryptData<ReplyToInvitePayload | ReplyPayload>(\n      secret,\n      jws.header.iv,\n      reply.payload\n    );\n    const from = reply.header.from;\n\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const epkThumbprint =\n      from === theirThumbprint\n        ? await getJWKthumbprint(threadInfo.theirEPK)\n        : threadInfo.myThumbprint;\n\n    return {\n      from: getNickname(from),\n      fromThumbprint: from,\n      epkThumbprint,\n      message: payload.message,\n      type: \"message\",\n      iat: reply.header.iat,\n      messageId: payload.messageId,\n      minAck: payload.minAck,\n      relay: payload.relay,\n    };\n  }\n\n  public async getEncryptedThread(threadId: ThreadID) {\n    return this.storage.readMessages(this.thumbprint, threadId);\n  }\n\n  public async getThreadInfo(thread: ThreadID) {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${thread}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const myRelay = threadInfo.relays[this.thumbprint];\n\n    return {\n      myRelay,\n      myNickname: getNickname(this.thumbprint),\n      theirNickname: getNickname(\n        await getJWKthumbprint(threadInfo.theirSignature)\n      ),\n    };\n  }\n\n  async makeBackup(password: string) {\n    const idJWKs = await exportKeyPair(this.identityKeyPair);\n    const storageJWKs = await exportKeyPair(this.storageKeyPair);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n    const payload = await this.storage.makeIdentityBackup(\n      this.thumbprint,\n      encryptedIdentity,\n      encryptedStorageKey\n    );\n\n    return signJWS(\n      {\n        alg: \"ES384\",\n        jwk: idJWKs.publicKeyJWK,\n      },\n      payload,\n      this.identityKeyPair.privateKey\n    ) as Promise<SignedBackup>;\n  }\n\n  private notifySubscribers() {\n    for (const sub of this.subscriptions) {\n      try {\n        sub?.();\n      } catch (e) {\n        // Ignore\n      }\n    }\n  }\n  private subscriptions = new Set<() => void>();\n  public subscribe(onChange: () => void) {\n    this.subscriptions ??= new Set<() => void>();\n    this.subscriptions.add(onChange);\n\n    return () => {\n      this.subscriptions.delete(onChange);\n    };\n  }\n}\n\nexport function incMessageId(messageId: string) {\n  let nextId = parseInt(messageId, 16) + 1;\n  if (nextId >= MAX_MESSAGE_ID) {\n    nextId = 1;\n  }\n  invariant(!Number.isNaN(nextId), `Invalid message id ${messageId} ${nextId}`);\n  const n = nextId.toString(16);\n  invariant(\n    !Number.isNaN(n),\n    `Invalid message toString ${messageId} ${nextId}`\n  );\n  return n;\n}\n\nexport type {\n  BackupPayload,\n  Invitation,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedTransport,\n  Thumbprint,\n  ThreadID,\n  UnpackTaggedString,\n};\nexport { GridStorage };\n"],"names":[],"version":3,"file":"types.d.ts.map"}
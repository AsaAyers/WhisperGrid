{"mappings":"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","sources":["<anon>","src/cli/index.ts","src/client/index.ts","src/client/GridStorage.ts","src/client/utils.ts","src/client/synAck.ts","src/cli/mainClientMenu.ts","src/cli/viewEncryptedThread.ts","src/cli/runWebserver.ts","src/browser/invariant.ts"],"sourcesContent":["var $bXzvz$inquirerprompts = require(\"@inquirer/prompts\");\nvar $bXzvz$path = require(\"path\");\nvar $bXzvz$fs = require(\"fs\");\nvar $bXzvz$crypto = require(\"crypto\");\nvar $bXzvz$lodashdebounce = require(\"lodash.debounce\");\nvar $bXzvz$jsrsasign = require(\"jsrsasign\");\nvar $bXzvz$fastify = require(\"fastify\");\nvar $bXzvz$fastifystatic = require(\"@fastify/static\");\nvar $bXzvz$fastifywebsocket = require(\"@fastify/websocket\");\nvar $bXzvz$fspromises = require(\"fs/promises\");\n\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ \n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable @typescript-eslint/no-explicit-any */ \n\nconst $bf90c0b94bdde3b6$export$9727364c1216843b = (str)=>Buffer.from(str.replace(\"-\", \"+\").replace(\"_\", \"/\"), \"base64\");\nconst $bf90c0b94bdde3b6$export$956a7f8e09e7a04 = (src)=>Buffer.from(src).toString(\"base64\").replace(\"+\", \"-\").replace(\"/\", \"_\").replace(\"=\", \"\");\nconst $bf90c0b94bdde3b6$export$1b0a11badccb060e = {\n    name: \"ECDH\",\n    namedCurve: \"P-384\"\n};\nconst $bf90c0b94bdde3b6$export$593cf972133c6bfa = {\n    name: \"ECDSA\",\n    namedCurve: \"P-384\"\n};\nconst $bf90c0b94bdde3b6$var$ecdsaKeyUseages = [\n    \"sign\",\n    \"verify\"\n];\nconst $bf90c0b94bdde3b6$export$a46aded5c6aac828 = {\n    name: \"ECDSA\",\n    hash: {\n        name: \"SHA-384\"\n    }\n};\nconst $bf90c0b94bdde3b6$var$keySymbol = Symbol(\"keySymbol\");\nasync function $bf90c0b94bdde3b6$export$30269e8f0eedc10a() {\n    const keyPair = await window.crypto.subtle.generateKey($bf90c0b94bdde3b6$export$593cf972133c6bfa, true, $bf90c0b94bdde3b6$var$ecdsaKeyUseages);\n    const thumbprint = await $bf90c0b94bdde3b6$export$d223eef5bee92cf8(await $bf90c0b94bdde3b6$export$96341dfa0e2e9076(keyPair.publicKey));\n    (0, $9f203e569b1fab49$export$89cea9803cad95d2)(thumbprint, `${thumbprint}/ECDSA`);\n    return keyPair;\n}\nasync function $bf90c0b94bdde3b6$export$b1dda1088d254686() {\n    const keyPair = await window.crypto.subtle.generateKey($bf90c0b94bdde3b6$export$1b0a11badccb060e, true, [\n        \"deriveKey\",\n        \"deriveBits\"\n    ]);\n    const thumbprint = await $bf90c0b94bdde3b6$export$d223eef5bee92cf8(await $bf90c0b94bdde3b6$export$96341dfa0e2e9076(keyPair.publicKey));\n    (0, $9f203e569b1fab49$export$89cea9803cad95d2)(thumbprint, `${thumbprint}/ECDH`);\n    return keyPair;\n}\nfunction $bf90c0b94bdde3b6$export$f5708dca728d7177(condition, message) {\n    if (!condition) throw new Error(message);\n}\nasync function $bf90c0b94bdde3b6$export$d8c619be39dc35fe(privateKey, publicKey) {\n    const bits = await window.crypto.subtle.deriveBits({\n        name: $bf90c0b94bdde3b6$export$1b0a11badccb060e.name,\n        public: publicKey\n    }, privateKey, 256);\n    return await window.crypto.subtle.importKey(\"raw\", bits, {\n        name: \"AES-GCM\"\n    }, false, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\nasync function $bf90c0b94bdde3b6$export$d71a6df60c6808b(header, payload, privateKey) {\n    const unixTimetsamp = Math.floor(Date.now() / 1000);\n    header.iat = unixTimetsamp;\n    const encodedHeader = (0, $bXzvz$jsrsasign.utf8tob64u)(JSON.stringify(header));\n    const encodedPayload = (0, $bXzvz$jsrsasign.utf8tob64u)(typeof payload === \"string\" ? payload : JSON.stringify(payload));\n    const dataToSign = `${encodedHeader}.${encodedPayload}`;\n    const signature = await window.crypto.subtle.sign($bf90c0b94bdde3b6$export$a46aded5c6aac828, privateKey, new TextEncoder().encode(dataToSign));\n    // Step 5: Encode the signature\n    const encodedSignature = (0, $bXzvz$jsrsasign.hextob64u)((0, $bXzvz$jsrsasign.ArrayBuffertohex)(signature));\n    // Step 6: Concatenate the encoded parts\n    const jws = `${dataToSign}.${encodedSignature}`;\n    return jws;\n}\nasync function $bf90c0b94bdde3b6$export$bcc5355044a25ec(jws, pubKey) {\n    if (jws.startsWith('\"') && jws.endsWith('\"')) jws = jws.slice(1, -1);\n    const [header, payload, signature] = jws.split(\".\");\n    const signedData = `${header}.${payload}`;\n    if (!pubKey) {\n        let headerObj;\n        try {\n            headerObj = JSON.parse((0, $bXzvz$jsrsasign.b64utoutf8)(header));\n        } catch (e) {\n        // ignore JSON parse errors\n        }\n        if (headerObj && \"jwk\" in headerObj && typeof headerObj.jwk === \"object\") {\n            const pubKey = await $bf90c0b94bdde3b6$export$f7283e97187223bd(\"ECDSA\", headerObj.jwk);\n            return $bf90c0b94bdde3b6$export$bcc5355044a25ec(jws, pubKey);\n        }\n        return false;\n    }\n    if (\"kty\" in pubKey) pubKey = await $bf90c0b94bdde3b6$export$f7283e97187223bd(\"ECDSA\", pubKey);\n    const isValid = await window.crypto.subtle.verify({\n        name: $bf90c0b94bdde3b6$export$593cf972133c6bfa.name,\n        hash: {\n            name: \"SHA-384\"\n        }\n    }, pubKey, (0, $bXzvz$jsrsasign.hextoArrayBuffer)((0, $bXzvz$jsrsasign.b64utohex)(signature)), new TextEncoder().encode(signedData));\n    return isValid;\n}\nasync function $bf90c0b94bdde3b6$export$d223eef5bee92cf8(jwk) {\n    $bf90c0b94bdde3b6$export$f5708dca728d7177(jwk.kty === \"EC\", \"Unsupported key type\");\n    const s = {\n        crf: jwk.crv,\n        kty: jwk.kty,\n        x: jwk.x,\n        y: jwk.y\n    };\n    const hex = (0, $bXzvz$jsrsasign.rstrtohex)(JSON.stringify(s));\n    const sha256 = await window.crypto.subtle.digest(\"SHA-256\", (0, $bXzvz$jsrsasign.hextoArrayBuffer)(hex));\n    const alg = jwk.alg ? `${jwk.alg}/` : \"\";\n    return `id-${alg}${(0, $bXzvz$jsrsasign.hextob64u)((0, $bXzvz$jsrsasign.ArrayBuffertohex)(sha256))}`;\n}\nfunction $bf90c0b94bdde3b6$export$96341dfa0e2e9076(key) {\n    return window.crypto.subtle.exportKey(\"jwk\", key);\n}\nasync function $bf90c0b94bdde3b6$export$87d43765c0bdfdff(keyPair) {\n    const privateKeyJWK = await $bf90c0b94bdde3b6$export$96341dfa0e2e9076(keyPair.privateKey);\n    const publicKeyJWK = await $bf90c0b94bdde3b6$export$96341dfa0e2e9076(keyPair.publicKey);\n    return {\n        privateKeyJWK: privateKeyJWK,\n        publicKeyJWK: publicKeyJWK\n    };\n}\nasync function $bf90c0b94bdde3b6$export$4f5b87a5ef040005(privateKeyJWK, password) {\n    const enc = new TextEncoder();\n    const passwordKey = await window.crypto.subtle.importKey(\"raw\", enc.encode(password), {\n        name: \"PBKDF2\"\n    }, false, [\n        \"deriveKey\"\n    ]);\n    const salt = window.crypto.getRandomValues(new Uint8Array(16));\n    const keyMaterial = await window.crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: 100000,\n        hash: \"SHA-256\"\n    }, passwordKey, {\n        name: \"AES-GCM\",\n        length: 256\n    }, false, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    const privateKeyString = JSON.stringify(privateKeyJWK);\n    const encryptedPrivateKey = await window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, keyMaterial, enc.encode(privateKeyString));\n    return [\n        Buffer.from(encryptedPrivateKey).toString(\"base64\"),\n        Buffer.from(iv).toString(\"base64\"),\n        Buffer.from(salt).toString(\"base64\")\n    ].join(\".\");\n}\nasync function $bf90c0b94bdde3b6$export$c97f585acdba2853(str, password) {\n    const [encryptedPrivateKey, iv, salt] = str.split(\".\").map((b64)=>Uint8Array.from(Buffer.from(b64, \"base64\")));\n    $bf90c0b94bdde3b6$export$f5708dca728d7177(encryptedPrivateKey && iv && salt, \"Invalid encrypted private key\");\n    const enc = new TextEncoder();\n    const passwordKey = await window.crypto.subtle.importKey(\"raw\", enc.encode(password), {\n        name: \"PBKDF2\"\n    }, false, [\n        \"deriveKey\"\n    ]);\n    const keyMaterial = await window.crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: 100000,\n        hash: \"SHA-256\"\n    }, passwordKey, {\n        name: \"AES-GCM\",\n        length: 256\n    }, false, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n    const decryptedPrivateKey = await window.crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, keyMaterial, encryptedPrivateKey);\n    const privateKeyJWK = JSON.parse(new TextDecoder().decode(decryptedPrivateKey));\n    return privateKeyJWK;\n}\nasync function $bf90c0b94bdde3b6$export$99859bc1ea511bf9(jws, pubKey) {\n    if (pubKey !== null) {\n        const isValid = await $bf90c0b94bdde3b6$export$bcc5355044a25ec(jws, pubKey);\n        $bf90c0b94bdde3b6$export$f5708dca728d7177(isValid, `JWS verification failed`);\n    }\n    return $bf90c0b94bdde3b6$export$56ce858a5181ed60(jws);\n}\nfunction $bf90c0b94bdde3b6$export$56ce858a5181ed60(jws) {\n    $bf90c0b94bdde3b6$export$f5708dca728d7177(typeof jws === \"string\", \"Expected a string\");\n    if (jws.startsWith('\"') && jws.endsWith('\"')) jws = jws.slice(1, -1);\n    const [encodedHeader, encodedPayload] = jws.split(\".\");\n    const header = JSON.parse((0, $bXzvz$jsrsasign.b64utoutf8)(encodedHeader));\n    let payload = (0, $bXzvz$jsrsasign.b64utoutf8)(encodedPayload);\n    try {\n        payload = JSON.parse(payload);\n    } catch (e) {\n    // ignore JSON parse errors\n    }\n    return {\n        header: header,\n        payload: payload\n    };\n}\nasync function $bf90c0b94bdde3b6$export$a130e185e3431961(type, jwk) {\n    return await window.crypto.subtle.importKey(\"jwk\", jwk, type === \"ECDH\" ? $bf90c0b94bdde3b6$export$1b0a11badccb060e : $bf90c0b94bdde3b6$export$593cf972133c6bfa, true, type === \"ECDH\" ? [\n        \"deriveKey\",\n        \"deriveBits\"\n    ] : [\n        \"sign\"\n    ]);\n}\nasync function $bf90c0b94bdde3b6$export$f7283e97187223bd(type, jwk) {\n    return await window.crypto.subtle.importKey(\"jwk\", jwk, type === \"ECDH\" ? $bf90c0b94bdde3b6$export$1b0a11badccb060e : $bf90c0b94bdde3b6$export$593cf972133c6bfa, true, type === \"ECDH\" ? [] : [\n        \"verify\"\n    ]);\n}\nasync function $bf90c0b94bdde3b6$export$57926b65d55505fc(t, type = \"ecdh\") {\n    return {\n        privateKey: await window.crypto.subtle.importKey(\"jwk\", t.privateKeyJWK, type === \"ecdh\" ? $bf90c0b94bdde3b6$export$1b0a11badccb060e : $bf90c0b94bdde3b6$export$593cf972133c6bfa, true, type === \"ecdh\" ? [\n            \"deriveKey\",\n            \"deriveBits\"\n        ] : [\n            \"sign\"\n        ]),\n        publicKey: await window.crypto.subtle.importKey(\"jwk\", t.publicKeyJWK, type === \"ecdh\" ? $bf90c0b94bdde3b6$export$1b0a11badccb060e : $bf90c0b94bdde3b6$export$593cf972133c6bfa, true, type === \"ecdh\" ? [] : [\n            \"verify\"\n        ])\n    };\n}\nconst $bf90c0b94bdde3b6$var$MIN_MESSAGE_SIZE = 30;\nasync function $bf90c0b94bdde3b6$export$cfb0e8a6f536315e(secret, message) {\n    try {\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        let msg = JSON.stringify({\n            m: message\n        });\n        if (msg.length < $bf90c0b94bdde3b6$var$MIN_MESSAGE_SIZE) msg = JSON.stringify({\n            random: (0, $bXzvz$jsrsasign.ArrayBuffertohex)(window.crypto.getRandomValues(new Uint8Array($bf90c0b94bdde3b6$var$MIN_MESSAGE_SIZE / 2)).buffer),\n            m: message\n        });\n        const encrypted = await window.crypto.subtle.encrypt({\n            name: \"AES-GCM\",\n            iv: iv\n        }, secret, new TextEncoder().encode(msg));\n        return {\n            iv: Buffer.from(iv).toString(\"base64\"),\n            encrypted: $bf90c0b94bdde3b6$export$956a7f8e09e7a04(encrypted)\n        };\n    } catch (e) {\n        throw new Error(\"Failed to encrypt \" + e?.message);\n    }\n}\nasync function $bf90c0b94bdde3b6$export$989b3bbdce9ac2d4(secret, iv, encryptedPayload) {\n    try {\n        const payloadBuffer = await window.crypto.subtle.decrypt({\n            name: \"AES-GCM\",\n            iv: $bf90c0b94bdde3b6$export$9727364c1216843b(iv)\n        }, secret, $bf90c0b94bdde3b6$export$9727364c1216843b(encryptedPayload));\n        const decoded = new TextDecoder().decode(payloadBuffer);\n        const decrypted = JSON.parse(decoded);\n        return decrypted?.m ?? decrypted;\n    } catch (e) {\n        throw new Error(\"Failed to decrypt \" + e?.message);\n    }\n}\n\n\nclass $fec366f672fe5d29$export$8688904fb0eaa63d {\n    data = new Map();\n    debugData() {\n        return Object.fromEntries(this.data.entries());\n    }\n    async loadIdentityBackup(backup) {\n        this.setItem(`identity:${backup.thumbprint}`, backup.identity);\n        Object.entries(backup.invites ?? {}).forEach(([key, value])=>{\n            this.appendItem(`invitations:${backup.thumbprint}`, key, {\n                unique: true\n            });\n            this.setItem(`invitation:${key}`, value);\n        });\n        Object.entries(backup.encryptedThreadKeys).forEach(([thumbprint, key])=>{\n            this.setItem(`encrypted-thread-key:${thumbprint}`, key);\n        });\n        Object.entries(backup.threads).forEach(([id, thread])=>{\n            const threadId = id;\n            this.appendItem(`threads:${backup.thumbprint}`, threadId);\n            this.setItem(`thread-info:${backup.thumbprint}:${threadId}`, thread.threadInfo);\n            this.setItem(`keyed-messages:${backup.thumbprint}:${threadId}`, thread.messages);\n        });\n    }\n    async makeIdentityBackup(thumbprint, idPrivateKey, storagePrivateKey) {\n        const identity = this.getItem(`identity:${thumbprint}`);\n        const encryptedThreadKeys = {};\n        return {\n            thumbprint: thumbprint,\n            identity: {\n                id: {\n                    jwk: identity.id.jwk,\n                    private: idPrivateKey\n                },\n                storage: {\n                    jwk: identity.storage.jwk,\n                    private: storagePrivateKey\n                }\n            },\n            invites: this.queryItem(`invitations:${thumbprint}`)?.reduce((memo, key)=>{\n                memo[key] = this.getItem(`invitation:${key}`);\n                encryptedThreadKeys[key] = this.getItem(`encrypted-thread-key:${key}`);\n                return memo;\n            }, {}),\n            threads: await this.queryItem(`threads:${thumbprint}`)?.reduce(async (m, key)=>{\n                const memo = await m;\n                const threadInfo = this.getItem(`thread-info:${thumbprint}:${key}`);\n                const messages = this.getItem(`keyed-messages:${thumbprint}:${key}`);\n                encryptedThreadKeys[threadInfo.myThumbprint] = this.getItem(`encrypted-thread-key:${threadInfo.myThumbprint}`);\n                memo[key] = {\n                    threadInfo: threadInfo,\n                    messages: messages\n                };\n                return memo;\n            }, Promise.resolve({})) ?? {},\n            encryptedThreadKeys: encryptedThreadKeys\n        };\n    }\n    hasItem = (key)=>{\n        return this.data.has(key);\n    };\n    removeItem = (key)=>{\n        this.data.delete(key);\n        return null;\n    };\n    queryItem = (key)=>{\n        return this.data.get(key);\n    };\n    getItem = (key)=>{\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(this.hasItem(key), `Key ${key} not found in storage.`);\n        return this.data.get(key);\n    };\n    setItem = (key, value)=>{\n        this.data.set(key, value);\n    };\n    appendItem = (key, value, { unique: unique = false } = {})=>{\n        let arr = this.queryItem(key);\n        if (!Array.isArray(arr)) arr = [];\n        if (unique && arr.includes(value)) return;\n        arr.push(value);\n        this.setItem(key, arr);\n    };\n    storeMessage(thumbprint, threadId, messageId, message) {\n        const index = this.queryItem(`keyed-messages:${thumbprint}:${threadId}`) ?? {\n            min: messageId,\n            max: messageId,\n            messages: []\n        };\n        index.messages.push(message);\n        this.setItem(`keyed-messages:${thumbprint}:${threadId}`, index);\n    }\n    readMessages(thumbprint, threadId) {\n        const { messages: messages } = this.getItem(`keyed-messages:${thumbprint}:${threadId}`);\n        return messages;\n    }\n}\n\n\n\n\n\nfunction $950dc8840a13c90b$export$56a086ad643c12e4(id, state) {\n    if (\"syn\" in id) {\n        if (state.syn === undefined) state.syn = id.syn;\n        else if (id.syn === (0, $9f203e569b1fab49$export$af15847d6300ede1)(state.syn)) state.syn = id.syn;\n        else throw new Error(`Syn out of order ${id.syn} - Expected: ${(0, $9f203e569b1fab49$export$af15847d6300ede1)(state.syn)}`);\n    } else {\n        if (!state.minAck || !state.maxAck) {\n            // initialize\n            state.minAck = id.ack;\n            state.maxAck = id.ack;\n        } else if (id.ack === (0, $9f203e569b1fab49$export$af15847d6300ede1)(state.maxAck)) {\n            // Next expected message (max)\n            state.maxAck = id.ack;\n            if (id.ack === (0, $9f203e569b1fab49$export$af15847d6300ede1)(state.minAck)) // min/ax are in sync --- This is the ideal scenario\n            state.minAck = id.ack;\n        } else if (id.ack === (0, $9f203e569b1fab49$export$af15847d6300ede1)(state.minAck)) // Increment the minAck\n        state.minAck = id.ack;\n        else if (id.ack <= state.minAck || id.ack === state.maxAck) // Ignore duplicate\n        return false;\n        else if (id.ack > state.maxAck) {\n            const min = parseInt(state.minAck, 16);\n            const ack = parseInt(id.ack, 16);\n            if (ack - min >= state.windowSize) throw new Error(`Missing ${ack - min} messages between ${state.minAck} and ${id.ack}`);\n            if (state.missing.length === 0) for(let i = min + 1; i < ack; i++)state.missing.push(i.toString(16));\n            const i = state.missing.findIndex((m)=>m === id.ack);\n            if (i !== -1) state.missing.splice(i, 1);\n            state.maxAck = id.ack;\n        } else throw new Error(`Ack out of order ${JSON.stringify(id)} ${JSON.stringify(state)}`);\n    }\n    return true;\n}\n\n\nconst $9f203e569b1fab49$var$keyNicknames = new Map();\nfunction $9f203e569b1fab49$export$89cea9803cad95d2(key, nickname) {\n    $9f203e569b1fab49$var$keyNicknames.set(key, nickname);\n}\nfunction $9f203e569b1fab49$export$1a98f7a90e54a705(key) {\n    return $9f203e569b1fab49$var$keyNicknames.get(key) + \"_\" + key.substring(key.length - 6);\n}\nlet $9f203e569b1fab49$var$messageIdForInviteTesting;\nfunction $9f203e569b1fab49$export$93d3c069f88f1516(messageId) {\n    $9f203e569b1fab49$var$messageIdForInviteTesting = messageId;\n}\nconst $9f203e569b1fab49$var$MAX_MESSAGE_ID = Number.MAX_SAFE_INTEGER / 2;\nclass $9f203e569b1fab49$export$1f2bb630327ac4b6 {\n    storage;\n    thumbprint;\n    identityKeyPair;\n    storageKeyPair;\n    isLocalClient;\n    clientNickname;\n    async setClientNickname(nickname) {\n        this.clientNickname = nickname;\n        if (nickname) {\n            $9f203e569b1fab49$export$89cea9803cad95d2(this.thumbprint, this.clientNickname);\n            $9f203e569b1fab49$export$89cea9803cad95d2(await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(await (0, $bf90c0b94bdde3b6$export$96341dfa0e2e9076)(this.storageKeyPair.publicKey)), `storage[${this.clientNickname}]`);\n        }\n    }\n    constructor(storage, thumbprint, identityKeyPair, storageKeyPair){\n        this.storage = storage;\n        this.thumbprint = thumbprint;\n        this.identityKeyPair = identityKeyPair;\n        this.storageKeyPair = storageKeyPair;\n        this.isLocalClient = true;\n        this.clientNickname = Math.random().toString(36).slice(2);\n        this.subscriptions = new Set();\n    }\n    async getThumbprint() {\n        return this.thumbprint;\n    }\n    static async generateClient(storage, password) {\n        const identity = await (0, $bf90c0b94bdde3b6$export$30269e8f0eedc10a)();\n        const storageKey = await (0, $bf90c0b94bdde3b6$export$b1dda1088d254686)();\n        const idJWKs = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(identity);\n        const storageJWKs = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(storageKey);\n        const encryptedIdentity = await (0, $bf90c0b94bdde3b6$export$4f5b87a5ef040005)(idJWKs.privateKeyJWK, password);\n        const encryptedStorageKey = await (0, $bf90c0b94bdde3b6$export$4f5b87a5ef040005)(storageJWKs.privateKeyJWK, password);\n        const thumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(idJWKs.publicKeyJWK);\n        storage.setItem(`identity:${thumbprint}`, {\n            id: {\n                jwk: idJWKs.publicKeyJWK,\n                private: encryptedIdentity\n            },\n            storage: {\n                jwk: storageJWKs.publicKeyJWK,\n                private: encryptedStorageKey\n            }\n        });\n        return $9f203e569b1fab49$export$1f2bb630327ac4b6.loadClient(storage, thumbprint, password);\n    }\n    static async loadFromBackup(storage, backup, password) {\n        if (typeof backup === \"string\") {\n            const jws = await (0, $bf90c0b94bdde3b6$export$99859bc1ea511bf9)(backup);\n            return $9f203e569b1fab49$export$1f2bb630327ac4b6.loadFromBackup(storage, jws.payload, password);\n        }\n        const identityPrivateKey = await (0, $bf90c0b94bdde3b6$export$c97f585acdba2853)(backup.identity.id.private, password);\n        const storagePrivateKey = await (0, $bf90c0b94bdde3b6$export$c97f585acdba2853)(backup.identity.storage.private, password);\n        const identityKeyPair = await (0, $bf90c0b94bdde3b6$export$57926b65d55505fc)({\n            privateKeyJWK: identityPrivateKey,\n            publicKeyJWK: backup.identity.id.jwk\n        }, \"ecdsa\");\n        const storageKeyPair = await (0, $bf90c0b94bdde3b6$export$57926b65d55505fc)({\n            privateKeyJWK: storagePrivateKey,\n            publicKeyJWK: backup.identity.storage.jwk\n        }, \"ecdh\");\n        await storage.loadIdentityBackup(backup);\n        const client = new $9f203e569b1fab49$export$1f2bb630327ac4b6(storage, backup.thumbprint, identityKeyPair, storageKeyPair);\n        return client;\n    }\n    static async loadClient(storage, thumbprint, password) {\n        const storedData = storage.getItem(`identity:${thumbprint}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(storedData, \"No identity found for thumbprint\");\n        const privateKeyJWK = await (0, $bf90c0b94bdde3b6$export$c97f585acdba2853)(storedData.id.private, password);\n        const id = await (0, $bf90c0b94bdde3b6$export$57926b65d55505fc)({\n            privateKeyJWK: privateKeyJWK,\n            publicKeyJWK: storedData.id.jwk\n        }, \"ecdsa\");\n        const storageKeys = await (0, $bf90c0b94bdde3b6$export$57926b65d55505fc)({\n            privateKeyJWK: await (0, $bf90c0b94bdde3b6$export$c97f585acdba2853)(storedData.storage.private, password),\n            publicKeyJWK: storedData.storage.jwk\n        }, \"ecdh\");\n        return new $9f203e569b1fab49$export$1f2bb630327ac4b6(storage, thumbprint, id, storageKeys);\n    }\n    async decryptFromSelf(message) {\n        const selfEncrypted = await (0, $bf90c0b94bdde3b6$export$99859bc1ea511bf9)(message, this.identityKeyPair.publicKey);\n        const epk = await (0, $bf90c0b94bdde3b6$export$f7283e97187223bd)(\"ECDH\", selfEncrypted.header.epk);\n        const secret = await (0, $bf90c0b94bdde3b6$export$d8c619be39dc35fe)(this.storageKeyPair.privateKey, epk);\n        const payload = await (0, $bf90c0b94bdde3b6$export$989b3bbdce9ac2d4)(secret, selfEncrypted.header.iv, selfEncrypted.payload);\n        return payload;\n    }\n    async encryptToSelf(message) {\n        const epk = await (0, $bf90c0b94bdde3b6$export$b1dda1088d254686)();\n        const jwks = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(epk);\n        const secret = await (0, $bf90c0b94bdde3b6$export$d8c619be39dc35fe)(epk.privateKey, this.storageKeyPair.publicKey);\n        const { iv: iv, encrypted: encrypted } = await (0, $bf90c0b94bdde3b6$export$cfb0e8a6f536315e)(secret, message);\n        const selfEncrypted = {\n            header: {\n                alg: \"ES384\",\n                jwk: (await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(this.identityKeyPair)).publicKeyJWK,\n                iat: 0,\n                sub: \"self-encrypted\",\n                iv: iv,\n                epk: jwks.publicKeyJWK\n            },\n            payload: encrypted\n        };\n        const encryptedJWS = await (0, $bf90c0b94bdde3b6$export$d71a6df60c6808b)(selfEncrypted.header, selfEncrypted.payload, this.identityKeyPair.privateKey);\n        // try {\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedJWS), \"Error encrypting message\");\n        const decryptedMessage = await this.decryptFromSelf(encryptedJWS);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(decryptedMessage, \"Decrypted message is empty\");\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(decryptedMessage === message || message === JSON.stringify(decryptedMessage), \"Decrypted message mismatch\");\n        // } catch (e: any) {\n        //   throw new Error(`Error encrypting message: ${e?.message ?? e}`);\n        // }\n        return encryptedJWS;\n    }\n    async createInvitation({ note: note, nickname: nickname }) {\n        const { thumbprint: thumbprint, jwks: jwks } = await this.makeThreadKeys();\n        const invitation = {\n            header: {\n                alg: \"ES384\",\n                jwk: (await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(this.identityKeyPair)).publicKeyJWK,\n                iat: 0,\n                sub: \"grid-invitation\"\n            },\n            payload: {\n                messageId: Number($9f203e569b1fab49$var$messageIdForInviteTesting ?? Math.floor(Math.random() * $9f203e569b1fab49$var$MAX_MESSAGE_ID)).toString(16),\n                epk: jwks.publicKeyJWK,\n                note: note,\n                nickname: nickname\n            }\n        };\n        const signedInvitation = await (0, $bf90c0b94bdde3b6$export$d71a6df60c6808b)(invitation.header, invitation.payload, this.identityKeyPair.privateKey);\n        this.storage.setItem(`invitation:${thumbprint}`, signedInvitation);\n        this.storage.appendItem(`invitations:${this.thumbprint}`, thumbprint, {\n            unique: true\n        });\n        this.storage.setItem(`threads:${this.thumbprint}`, this.storage.queryItem(`threads:${this.thumbprint}`) ?? []);\n        this.notifySubscribers();\n        return signedInvitation;\n    }\n    async replyToInvitation(signedInvite, message, nickname, { setMyRelay: setMyRelay } = {}) {\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(signedInvite), \"Invalid invitation signature\");\n        const invite = await (0, $bf90c0b94bdde3b6$export$99859bc1ea511bf9)(signedInvite);\n        const threadId = await this.startThread(signedInvite, invite.payload.epk, invite.header.jwk);\n        const reply = this.replyToThread(threadId, message, {\n            selfSign: true,\n            nickname: nickname,\n            setMyRelay: setMyRelay\n        });\n        return reply;\n    }\n    async startThread(signedInvite, theirEPKJWK, theirSignature, myThumbprint) {\n        if (!myThumbprint) {\n            const { thumbprint: thumbprint } = await this.makeThreadKeys();\n            myThumbprint = thumbprint;\n        }\n        const keyBackup = this.storage.getItem(`encrypted-thread-key:${myThumbprint}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(keyBackup, `Thread key not found ${myThumbprint}`);\n        const signatureThumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(theirSignature);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(!myThumbprint || signatureThumbprint !== this.thumbprint, \"Cannot start a thread with yourself\");\n        const thumbprints = [\n            await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(theirEPKJWK),\n            myThumbprint\n        ].sort();\n        const threadId = (0, $bXzvz$jsrsasign.ArrayBuffertohex)(await window.crypto.subtle.digest(\"SHA-256\", Buffer.from(thumbprints.join(\":\"))));\n        this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, {\n            missing: [],\n            windowSize: 5,\n            maxAck: undefined,\n            minAck: undefined,\n            syn: undefined,\n            myThumbprint: myThumbprint,\n            theirEPK: theirEPKJWK,\n            signedInvite: signedInvite,\n            theirSignature: theirSignature,\n            relays: {}\n        });\n        this.storage.appendItem(`threads:${this.thumbprint}`, threadId);\n        await this.appendThread(signedInvite, threadId);\n        this.notifySubscribers();\n        return threadId;\n    }\n    async getThreads() {\n        return this.storage.queryItem(`threads:${this.thumbprint}`) ?? [];\n    }\n    async getInvitationIds() {\n        return this.storage.queryItem(`invitations:${this.thumbprint}`) ?? [];\n    }\n    async getInvitations() {\n        return (await this.getInvitationIds()).map((t)=>this.storage.getItem(`invitation:${t}`));\n    }\n    async getInvitation(thumbprint) {\n        return this.storage.getItem(`invitation:${thumbprint}`);\n    }\n    async makeThreadKeys() {\n        const threadKey = await (0, $bf90c0b94bdde3b6$export$b1dda1088d254686)();\n        const jwks = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(threadKey);\n        const thumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(jwks.publicKeyJWK);\n        $9f203e569b1fab49$export$89cea9803cad95d2(thumbprint, `thread[${this.clientNickname}]`);\n        const keyBackup = await this.encryptToSelf(JSON.stringify(jwks));\n        this.storage.setItem(`encrypted-thread-key:${thumbprint}`, keyBackup);\n        return {\n            thumbprint: thumbprint,\n            jwks: jwks\n        };\n    }\n    async readThreadSecret(threadThumbprint) {\n        const threadInfo = this.storage.getItem(`thread-info:${this.thumbprint}:${threadThumbprint}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadInfo, \"Thread not found\");\n        const publicJWK = threadInfo.theirEPK;\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(publicJWK, `Public key not found ${threadInfo.theirEPK}`);\n        const encryptedBackup = this.storage.getItem(`encrypted-thread-key:${threadInfo.myThumbprint}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(typeof encryptedBackup === \"string\", `Thread key not found ${threadInfo.myThumbprint}`);\n        const jwks = JSON.parse(await this.decryptFromSelf(encryptedBackup));\n        const pKey = await (0, $bf90c0b94bdde3b6$export$f7283e97187223bd)(\"ECDH\", publicJWK);\n        const privateKey = await (0, $bf90c0b94bdde3b6$export$a130e185e3431961)(\"ECDH\", jwks.privateKeyJWK);\n        return {\n            secret: await (0, $bf90c0b94bdde3b6$export$d8c619be39dc35fe)(privateKey, pKey),\n            epk: jwks.publicKeyJWK\n        };\n    }\n    async replyToThread(threadId, message, options) {\n        const { secret: secret, epk: epk } = await this.readThreadSecret(threadId);\n        const threadInfo = this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadInfo, \"Thread not found\");\n        const messageId = threadInfo.syn ?? Number($9f203e569b1fab49$var$messageIdForInviteTesting ? parseInt(\"100000\", 16) + $9f203e569b1fab49$var$messageIdForInviteTesting : Math.floor(Math.random() * $9f203e569b1fab49$var$MAX_MESSAGE_ID)).toString(16);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(typeof messageId === \"string\", `Invalid message id ${messageId}`);\n        const nextId = $9f203e569b1fab49$export$af15847d6300ede1(messageId);\n        if (options?.setMyRelay) threadInfo.relays[this.thumbprint] = options.setMyRelay;\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadInfo.minAck, `Missing minAck in \"thread-info\" ${message}`);\n        let replyMessage = {\n            header: {\n                iat: 0,\n                alg: \"ES384\",\n                sub: \"grid-reply\",\n                re: threadId,\n                iv: \"\",\n                from: this.thumbprint\n            },\n            payload: {\n                messageId: nextId,\n                message: message,\n                minAck: threadInfo.minAck\n            }\n        };\n        // threadInfo.syn = nextId;\n        this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, threadInfo);\n        if (options?.selfSign && options.nickname) {\n            const ack = {\n                header: {\n                    ...replyMessage.header,\n                    sub: \"reply-to-invite\",\n                    jwk: await (0, $bf90c0b94bdde3b6$export$96341dfa0e2e9076)(this.identityKeyPair.publicKey),\n                    invite: await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirEPK),\n                    epk: epk\n                },\n                payload: {\n                    ...replyMessage.payload,\n                    nickname: options.nickname,\n                    messageId: Number($9f203e569b1fab49$var$messageIdForInviteTesting ? parseInt(\"100000\", 16) + $9f203e569b1fab49$var$messageIdForInviteTesting : Math.floor(Math.random() * $9f203e569b1fab49$var$MAX_MESSAGE_ID)).toString(16)\n                }\n            };\n            replyMessage = ack;\n        }\n        if (options?.setMyRelay) replyMessage.payload.relay = options.setMyRelay;\n        const { iv: iv, encrypted: encrypted } = await (0, $bf90c0b94bdde3b6$export$cfb0e8a6f536315e)(secret, replyMessage.payload);\n        replyMessage.header.iv = iv;\n        const encryptedJWS = await (0, $bf90c0b94bdde3b6$export$d71a6df60c6808b)(replyMessage.header, encrypted, this.identityKeyPair.privateKey);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)((0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedJWS, this.identityKeyPair.publicKey), \"Error encrypting message\");\n        const theirThumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirSignature);\n        const relay = threadInfo.relays[theirThumbprint];\n        await this.appendThread(encryptedJWS, threadId);\n        return {\n            reply: encryptedJWS,\n            threadId: threadId,\n            relay: relay\n        };\n    }\n    async appendThread(encryptedMessage, threadId) {\n        const jws = (0, $bf90c0b94bdde3b6$export$56ce858a5181ed60)(encryptedMessage);\n        if (!threadId) switch(jws.header.sub){\n            case \"grid-invitation\":\n                // const invite = jws as Invitation;\n                throw new Error(\"Not Implemented\");\n            case \"reply-to-invite\":\n                {\n                    const isValid = (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage);\n                    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(isValid, \"Expected a self-signed message\");\n                    const reply = jws;\n                    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(reply.header.epk, \"First message must have an epk\");\n                    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(reply.header.invite, 'First message must have an \"invite\" header');\n                    const invitationThumbprint = reply.header.invite;\n                    const invitation = this.storage.getItem(`invitation:${invitationThumbprint}`);\n                    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(invitation, \"Invitation not found \" + invitationThumbprint);\n                    const invitationJWS = await (0, $bf90c0b94bdde3b6$export$99859bc1ea511bf9)(invitation);\n                    const myThumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(invitationJWS.payload.epk);\n                    threadId = await this.startThread(invitation, reply.header.epk, reply.header.jwk, myThumbprint);\n                // FALLS THROUGH\n                }\n            case \"grid-reply\":\n                {\n                    const reply = jws;\n                    threadId ??= reply.header.re;\n                    const threadInfo = this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`);\n                    const fromMe = reply.header.from === this.thumbprint;\n                    let isValid = false;\n                    if (fromMe) isValid = await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage, this.identityKeyPair.publicKey);\n                    else isValid = await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage, threadInfo.theirSignature);\n                    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(isValid, \"Invalid message signature\");\n                    return this.appendThread(encryptedMessage, threadId);\n                }\n        }\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadId, \"Thread not found\");\n        const message = await this.decryptMessage(threadId, encryptedMessage);\n        const threadInfo = {\n            ...this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`)\n        };\n        const fromMe = message.fromThumbprint === this.thumbprint;\n        let isValid;\n        if (fromMe) isValid = await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage, this.identityKeyPair.publicKey);\n        else isValid = await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage, threadInfo.theirSignature);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(isValid, \"Invalid message signature\");\n        const storeMessage = (0, $950dc8840a13c90b$export$56a086ad643c12e4)(fromMe ? {\n            syn: message.messageId\n        } : {\n            ack: message.messageId\n        }, threadInfo);\n        if (storeMessage) {\n            const m = this.storage.queryItem(`keyed-messages:${this.thumbprint}:${threadId}`)?.messages;\n            (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(m ? !m.includes(encryptedMessage) : true, // m?.[0] !== encryptedMessage || lastMessage !== encryptedMessage,\n            `Message already exists in thread ${JSON.stringify({\n                nickname: this.clientNickname,\n                messageId: message.messageId,\n                sub: jws.header.sub,\n                threadId: threadId,\n                messageIndex: m?.indexOf(encryptedMessage)\n            }, null, 2)}`);\n            if (message.relay) {\n                threadInfo.relays[await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirSignature)] = message.relay;\n                if (message.relay && message.relay.match(/^https?:\\/\\/ntfy.sh\\/[^.]+$/)) threadInfo.relays[this.thumbprint] = message.relay;\n            }\n            this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, threadInfo);\n            this.storage.storeMessage(this.thumbprint, threadId, message.messageId, encryptedMessage);\n            this.notifySubscribers();\n        } else console.warn(\"Skipping message\", message.messageId);\n        return {\n            threadId: threadId,\n            message: message,\n            relay: message.relay\n        };\n    }\n    async decryptThread(threadId) {\n        const thread = await this.getEncryptedThread(threadId);\n        const messages = await Promise.all(thread.map(async (message)=>{\n            return typeof message === \"string\" ? this.decryptMessage(threadId, message) : message;\n        }));\n        messages.sort((a, b)=>{\n            if (a.from !== b.from) {\n                if (a.minAck && a.minAck < b.messageId) return 1;\n                if (b.minAck && b.minAck < a.messageId) return 1;\n            }\n            const order = (a.type === \"invite\" ? -1 : 0) || (b.type === \"invite\" ? 1 : 0) || b.iat - a.iat || (a.from === b.from ? a.messageId.localeCompare(b.messageId) : 0);\n            return order;\n        });\n        return messages;\n    }\n    async decryptMessage(threadId, encryptedMessage) {\n        const threadInfo = this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`);\n        const jws = await (0, $bf90c0b94bdde3b6$export$99859bc1ea511bf9)(encryptedMessage, null);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadInfo, \"Thread not found\");\n        if (jws.header.sub === \"grid-invitation\") {\n            // Looks like an Invite\n            (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(encryptedMessage), \"Invalid message signature\");\n            const jwsInvite = jws;\n            const message = `Invite from ${jwsInvite.payload.nickname}.\\nNote: ${jwsInvite.payload.note ?? \"(none)\"}`;\n            const from = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(jwsInvite.header.jwk);\n            if (jwsInvite.payload.nickname) $9f203e569b1fab49$export$89cea9803cad95d2(from, jwsInvite.payload.nickname);\n            return {\n                from: $9f203e569b1fab49$export$1a98f7a90e54a705(from),\n                fromThumbprint: from,\n                epkThumbprint: await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(jwsInvite.payload.epk),\n                message: message,\n                type: \"invite\",\n                iat: jwsInvite.header.iat,\n                messageId: jwsInvite.payload.messageId,\n                minAck: undefined\n            };\n        }\n        const reply = jws;\n        const { secret: secret } = await this.readThreadSecret(threadId);\n        const payload = await (0, $bf90c0b94bdde3b6$export$989b3bbdce9ac2d4)(secret, jws.header.iv, reply.payload);\n        const from = reply.header.from;\n        const theirThumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirSignature);\n        const epkThumbprint = from === theirThumbprint ? await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirEPK) : threadInfo.myThumbprint;\n        return {\n            from: $9f203e569b1fab49$export$1a98f7a90e54a705(from),\n            fromThumbprint: from,\n            epkThumbprint: epkThumbprint,\n            message: payload.message,\n            type: \"message\",\n            iat: reply.header.iat,\n            messageId: payload.messageId,\n            minAck: payload.minAck,\n            relay: payload.relay\n        };\n    }\n    async getEncryptedThread(threadId) {\n        return this.storage.readMessages(this.thumbprint, threadId);\n    }\n    async getThreadInfo(thread) {\n        const threadInfo = this.storage.getItem(`thread-info:${this.thumbprint}:${thread}`);\n        (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(threadInfo, \"Thread not found\");\n        const myRelay = threadInfo.relays[this.thumbprint];\n        return {\n            myRelay: myRelay,\n            myNickname: $9f203e569b1fab49$export$1a98f7a90e54a705(this.thumbprint),\n            theirNickname: $9f203e569b1fab49$export$1a98f7a90e54a705(await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(threadInfo.theirSignature))\n        };\n    }\n    async makeBackup(password) {\n        const idJWKs = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(this.identityKeyPair);\n        const storageJWKs = await (0, $bf90c0b94bdde3b6$export$87d43765c0bdfdff)(this.storageKeyPair);\n        const encryptedIdentity = await (0, $bf90c0b94bdde3b6$export$4f5b87a5ef040005)(idJWKs.privateKeyJWK, password);\n        const encryptedStorageKey = await (0, $bf90c0b94bdde3b6$export$4f5b87a5ef040005)(storageJWKs.privateKeyJWK, password);\n        const payload = await this.storage.makeIdentityBackup(this.thumbprint, encryptedIdentity, encryptedStorageKey);\n        return (0, $bf90c0b94bdde3b6$export$d71a6df60c6808b)({\n            alg: \"ES384\",\n            jwk: idJWKs.publicKeyJWK\n        }, payload, this.identityKeyPair.privateKey);\n    }\n    notifySubscribers() {\n        for (const sub of this.subscriptions)try {\n            sub?.();\n        } catch (e) {\n        // Ignore\n        }\n    }\n    subscriptions;\n    subscribe(onChange) {\n        this.subscriptions ??= new Set();\n        this.subscriptions.add(onChange);\n        return ()=>{\n            this.subscriptions.delete(onChange);\n        };\n    }\n}\nfunction $9f203e569b1fab49$export$af15847d6300ede1(messageId) {\n    let nextId = parseInt(messageId, 16) + 1;\n    if (nextId >= $9f203e569b1fab49$var$MAX_MESSAGE_ID) nextId = 1;\n    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(!Number.isNaN(nextId), `Invalid message id ${messageId} ${nextId}`);\n    const n = nextId.toString(16);\n    (0, $bf90c0b94bdde3b6$export$f5708dca728d7177)(!Number.isNaN(n), `Invalid message toString ${messageId} ${nextId}`);\n    return n;\n}\n\n\n\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */ \n/* eslint-disable @typescript-eslint/no-explicit-any */ \n\n\nasync function $130b50bf591698bb$export$5d1a368113f048de(client, threadId) {\n    const thread = await client.decryptThread(threadId);\n    const threadInfo = await client.getThreadInfo(threadId);\n    if (threadInfo.myRelay) {\n        let json;\n        try {\n            console.log(`fetching updates from... ${threadInfo.myRelay}`);\n            const response = await fetch(`${threadInfo.myRelay}/json?since=all&poll=1`);\n            const text = await response.text();\n            await text.trim().split(\"\\n\").reduce(async (p, line)=>{\n                await p;\n                json = JSON.parse(line);\n                if (json?.message) await client.appendThread(json.message, threadId).catch(()=>{\n                // Ignore errors about duplicate messages. This is expected.\n                });\n            }, Promise.resolve());\n        } catch (e) {\n            console.error(e);\n        }\n    }\n    console.log(`Thread: ${threadId}\\n--------------------------------------------`);\n    thread.map((message)=>{\n        console.log(`${message.type} From: ${message.from} ${new Date(message.iat * 1000)}\\n${message.message}\\n--------------------------------------------`);\n    });\n    const selection = await (0, $bXzvz$inquirerprompts.select)({\n        message: \"What would you like to do?\",\n        choices: [\n            threadInfo.myRelay ? {\n                name: \"Refresh\",\n                value: \"refresh\"\n            } : null,\n            {\n                name: \"Reply\",\n                value: \"reply\"\n            },\n            {\n                name: \"Reply (in $EDITOR)\",\n                value: \"replyEditor\"\n            },\n            {\n                name: \"Paste encrypted message\",\n                value: \"paste\"\n            },\n            {\n                name: \"View message details\",\n                value: \"viewDetils\"\n            },\n            {\n                name: threadInfo.myRelay ? \"Change Relay\" : \"Set Relay\",\n                value: \"setRelay\"\n            },\n            {\n                name: \"Back to main menu\",\n                value: \"back\"\n            }\n        ].filter((n)=>n != null)\n    });\n    switch(selection){\n        case \"back\":\n            return;\n        case \"setRelay\":\n            {\n                let message = \"Are you sure you want to remove your relay? The operation takes effect while sending a message\";\n                let newRelayUrl = \"\";\n                if (!threadInfo.myRelay) {\n                    const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n                    newRelayUrl = `https://ntfy.sh/${(0, $bXzvz$jsrsasign.ArrayBuffertohex)(topicArray.buffer)}`;\n                    message = `Use ${newRelayUrl} to send future messages? The operation takes effect while sending a message`;\n                }\n                if (await (0, $bXzvz$inquirerprompts.confirm)({\n                    message: message\n                })) {\n                    const selection = await (0, $bXzvz$inquirerprompts.select)({\n                        message: \"What would you like to do?\",\n                        choices: [\n                            {\n                                name: \"Reply\",\n                                value: \"reply\"\n                            },\n                            {\n                                name: \"Reply (in $EDITOR)\",\n                                value: \"replyEditor\"\n                            },\n                            {\n                                name: \"Back to main menu\",\n                                value: \"back\"\n                            }\n                        ]\n                    });\n                    if (selection === \"reply\" || selection === \"replyEditor\") await $130b50bf591698bb$var$replyMenu(client, threadId, selection, {\n                        setMyRelay: newRelayUrl\n                    });\n                }\n                break;\n            }\n        case \"replyEditor\":\n        case \"reply\":\n            await $130b50bf591698bb$var$replyMenu(client, threadId, selection);\n            break;\n        case \"paste\":\n            {\n                const message = await (0, $bXzvz$inquirerprompts.input)({\n                    required: false,\n                    message: \"Paste the encrypted reply you recieved (leave empty to cancel)\"\n                });\n                if (message) await client.appendThread(message, threadId);\n                break;\n            }\n        case \"viewDetils\":\n            {\n                const index = await (0, $bXzvz$inquirerprompts.select)({\n                    message: \"Which message would you like to inspect?\",\n                    choices: thread.map((message, index)=>({\n                            name: `From: ${message.from} ${new Date(message.iat * 1000)}\\n${message.message}`,\n                            value: index\n                        }))\n                });\n                if (index >= 0) {\n                    console.log(thread[index]);\n                    const encrypted = await client.getEncryptedThread(threadId);\n                    console.log(encrypted[index]);\n                }\n            }\n    }\n    return $130b50bf591698bb$export$5d1a368113f048de(client, threadId);\n}\nasync function $130b50bf591698bb$var$replyMenu(client, threadId, variant, options = {}) {\n    const prompt = variant === \"reply\" ? (0, $bXzvz$inquirerprompts.input) : (0, $bXzvz$inquirerprompts.editor);\n    const message = await prompt({\n        required: false,\n        message: \"Enter your message. (leave empty to cancel)\"\n    });\n    if (message) {\n        const { reply: reply, relay: relay } = await client.replyToThread(threadId, message, {\n            setMyRelay: options.setMyRelay\n        });\n        await (0, $50dcff3ae6a8aa6d$export$1a84ddaebc60eb8a)(reply, relay);\n    }\n}\n\n\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */ \n\n\n\n\nfunction $0888d7c14328ed29$export$f5708dca728d7177(condition, message) {\n    if (!condition) throw new Error(message);\n}\n\n\n\nvar $9282f0b1a67aebb3$var$$parcel$__dirname = $bXzvz$path.resolve(__dirname, \"../../src/cli\");\nconst $9282f0b1a67aebb3$var$host = \"localhost\";\nconst $9282f0b1a67aebb3$var$port = 3000 + Math.floor(Math.random() * 1000);\nasync function $9282f0b1a67aebb3$export$5640fea681d7e95f(client) {\n    const app = (0, ($parcel$interopDefault($bXzvz$fastify)))({\n        logger: false\n    });\n    app.register((0, ($parcel$interopDefault($bXzvz$fastifywebsocket))));\n    app.register(async (fastify)=>{\n        fastify.get(\"/client-socket\", {\n            websocket: true\n        }, async (socket)=>{\n            socket.on(\"message\", async (message)=>{\n                const data = JSON.parse(message.toString());\n                if (data.requestId && data.method && Array.isArray(data.args)) {\n                    const method = client[data.method];\n                    if (typeof method === \"function\") try {\n                        // @ts-expect-error I think TS can't verify that the args and return\n                        // value match the method\n                        const result = await method.apply(client, data.args);\n                        socket.send(JSON.stringify({\n                            requestId: data.requestId,\n                            result: result\n                        }));\n                    } catch (e) {\n                        socket.send(JSON.stringify({\n                            requestId: data.requestId,\n                            error: e?.message\n                        }));\n                    }\n                }\n            });\n            socket.send(JSON.stringify({\n                requestId: \"init\",\n                result: null\n            }));\n        });\n    });\n    const root = (0, ($parcel$interopDefault($bXzvz$path))).join($9282f0b1a67aebb3$var$$parcel$__dirname, \"../../dist/\");\n    (0, $0888d7c14328ed29$export$f5708dca728d7177)((0, ($parcel$interopDefault($bXzvz$fspromises))).access(root), `${root} is not a directory: ${root}`);\n    app.register((0, ($parcel$interopDefault($bXzvz$fastifystatic))), {\n        root: root,\n        prefix: \"/WhisperGrid/\"\n    });\n    app.get(\"/WhisperGrid\", async (request, reply)=>{\n        return reply.sendFile(\"index.html\", root);\n    });\n    app.setNotFoundHandler(async (request, reply)=>{\n        if (request.url.startsWith(\"/WhisperGrid\")) return reply.status(404).sendFile(\"404.html\", root);\n        if (request.url.startsWith(\"/favicon.ico\")) return reply.status(404).send();\n        return reply.redirect(`/WhisperGrid/`);\n    });\n    app.listen({\n        host: $9282f0b1a67aebb3$var$host,\n        port: $9282f0b1a67aebb3$var$port\n    }).then((url)=>{\n        console.log(`Server running at ${url}`);\n        console.log(`root: ${root}`);\n    });\n    return new Promise(()=>{});\n}\n\n\nasync function $50dcff3ae6a8aa6d$export$6dcc8f92a4b45952(client) {\n    const invitations = await client.getInvitationIds();\n    const threads = await client.getThreads();\n    console.clear();\n    const selection = await (0, $bXzvz$inquirerprompts.rawlist)({\n        message: \"What would you like to do?\",\n        choices: [\n            {\n                name: \"Run local Webserver\",\n                value: \"webserver\"\n            },\n            {\n                name: \"Create Invitation\",\n                value: \"createInvitation\"\n            },\n            ...invitations.map((value)=>({\n                    name: `View Invitation: ${value}`,\n                    value: value\n                })),\n            {\n                name: \"Reply to Invitation\",\n                value: \"replyToInvitation\"\n            },\n            ...threads.map((value)=>({\n                    name: `View Thread: ${value}`,\n                    value: value\n                })),\n            {\n                name: \"Exit\",\n                value: \"exit\"\n            }\n        ]\n    });\n    if (selection === \"exit\") process.exit(0);\n    else if (selection === \"createInvitation\") await $50dcff3ae6a8aa6d$var$createInvitationMenu(client);\n    else if (selection === \"replyToInvitation\") await $50dcff3ae6a8aa6d$var$replyToInvitationMenu(client);\n    else if (selection === \"webserver\") return (0, $9282f0b1a67aebb3$export$5640fea681d7e95f)(client);\n    if (threads.includes(selection)) await (0, $130b50bf591698bb$export$5d1a368113f048de)(client, selection);\n    if (invitations.includes(selection)) {\n        const invitation = client.getInvitation(selection);\n        console.log(invitation);\n        const reply = await (0, $bXzvz$inquirerprompts.input)({\n            required: false,\n            message: \"If you have received a reply, paste it here, or leave this empty to continue to the main menu\"\n        });\n        if (reply) {\n            const { threadId: threadId } = await client.appendThread(reply);\n            await (0, $130b50bf591698bb$export$5d1a368113f048de)(client, threadId);\n        }\n    }\n}\nasync function $50dcff3ae6a8aa6d$var$createInvitationMenu(client) {\n    const nickname = await (0, $bXzvz$inquirerprompts.input)({\n        message: \"What would you like your nickname to be in this conversation?\"\n    });\n    const note = await (0, $bXzvz$inquirerprompts.input)({\n        required: false,\n        message: \"(optional) Note to include with the invitation\"\n    });\n    const invite = await client.createInvitation({\n        note: note,\n        nickname: nickname\n    });\n    console.log(`Invitation created. Share the text below to allow friends to encrypt messages to you.`);\n    console.log(invite);\n    console.log(\"\\n\\n\\n\");\n}\nasync function $50dcff3ae6a8aa6d$var$replyToInvitationMenu(client) {\n    const invite = await (0, $bXzvz$inquirerprompts.input)({\n        message: \"Paste the invitation here\"\n    });\n    if (!invite) return;\n    const isValid = await (0, $bf90c0b94bdde3b6$export$bcc5355044a25ec)(invite);\n    if (!isValid) {\n        console.log(\"Invalid invite\");\n        return;\n    }\n    const jws = (0, $bf90c0b94bdde3b6$export$56ce858a5181ed60)(invite);\n    const thumbprint = await (0, $bf90c0b94bdde3b6$export$d223eef5bee92cf8)(jws.payload.epk);\n    console.log(`Invitation Thumbprint: ${thumbprint}`);\n    console.log(`Nickname: ${jws.payload.nickname}`);\n    console.log(`Note: ${jws.payload.note}`);\n    const nickname = await (0, $bXzvz$inquirerprompts.input)({\n        message: \"What would you like your nickname to be in this conversation?\",\n        required: true\n    });\n    let setMyRelay = undefined;\n    const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n    const newRelayUrl = `https://ntfy.sh/${(0, $bXzvz$jsrsasign.ArrayBuffertohex)(topicArray.buffer)}`;\n    const message = `Use ${newRelayUrl} to send future messages?`;\n    if (await (0, $bXzvz$inquirerprompts.confirm)({\n        message: message\n    })) setMyRelay = newRelayUrl;\n    const reply = await (0, $bXzvz$inquirerprompts.input)({\n        required: false,\n        message: \"Enter your reply, or leave empty to cancel\"\n    });\n    if (reply) {\n        const { threadId: threadId, reply: message, relay: relay } = await client.replyToInvitation(invite, reply, nickname, {\n            setMyRelay: setMyRelay\n        });\n        await $50dcff3ae6a8aa6d$export$1a84ddaebc60eb8a(message, relay);\n        return (0, $130b50bf591698bb$export$5d1a368113f048de)(client, threadId);\n    }\n}\nasync function $50dcff3ae6a8aa6d$export$1a84ddaebc60eb8a(message, relay) {\n    console.log(`Here is the message for you to send to the recipient`);\n    console.log(message);\n    if (!relay) await (0, $bXzvz$inquirerprompts.confirm)({\n        message: \"Press enter to continue\"\n    });\n    else {\n        const sendToRelay = await (0, $bXzvz$inquirerprompts.confirm)({\n            message: `Send message to relay? ${relay}`\n        });\n        if (sendToRelay) await fetch(relay, {\n            method: \"POST\",\n            body: message\n        }).catch(console.error);\n    }\n}\n\n\n$parcel$global.window ??= {};\n// @ts-expect-error The main target of the project is browsers, so it relies on window.crypto\nwindow.crypto = (0, ($parcel$interopDefault($bXzvz$crypto)));\nasync function $a09f43455a860df9$var$main() {\n    console.clear();\n    const files = await (0, $bXzvz$fs.promises).readdir(\".\");\n    const jwsTxtFiles = files.filter((file)=>file.endsWith(\".jws.txt\"));\n    if (jwsTxtFiles.length > 0) {\n        const filename = await (0, $bXzvz$inquirerprompts.rawlist)({\n            message: \"Which file would you like to open?\",\n            choices: [\n                ...jwsTxtFiles.map((file)=>({\n                        name: $bXzvz$path.basename(file, \".jws.txt\"),\n                        value: file\n                    })),\n                {\n                    value: \"newIdentity\",\n                    name: \"Create a new identity\"\n                }\n            ]\n        });\n        if (filename === \"newIdentity\") return $a09f43455a860df9$var$makeNewIdentity();\n        const pass = await (0, $bXzvz$inquirerprompts.password)({\n            message: \"Enter pass phrase to decrypt file\"\n        });\n        const backup = await (0, $bXzvz$fs.promises).readFile(filename, \"utf-8\");\n        try {\n            const client = await (0, $9f203e569b1fab49$export$1f2bb630327ac4b6).loadFromBackup(new (0, $fec366f672fe5d29$export$8688904fb0eaa63d)(), backup, pass);\n            client.subscribe((0, ($parcel$interopDefault($bXzvz$lodashdebounce)))(async ()=>{\n                const backup = await client.makeBackup(pass);\n                await (0, $bXzvz$fs.promises).writeFile(filename, backup);\n            }, 500));\n            // eslint-disable-next-line no-constant-condition\n            while(true)await (0, $50dcff3ae6a8aa6d$export$6dcc8f92a4b45952)(client);\n        } catch (e) {\n            console.error(\"Error loading backup\", e);\n            process.exit(1);\n        }\n    } else {\n        const newIdentity = await (0, $bXzvz$inquirerprompts.select)({\n            message: \"No backup files found. Would you like to create a new identity?\",\n            choices: [\n                {\n                    name: \"Yes\",\n                    value: \"yes\"\n                },\n                {\n                    name: \"No\",\n                    value: \"no\"\n                }\n            ]\n        });\n        if (newIdentity === \"no\") process.exit(0);\n        return $a09f43455a860df9$var$makeNewIdentity();\n    }\n}\nasync function $a09f43455a860df9$var$makeNewIdentity() {\n    let pass1 = \"\";\n    for(let tries = 0; tries < 3; tries++){\n        pass1 = await (0, $bXzvz$inquirerprompts.password)({\n            message: \"Enter pass phrase to encrypt your new identity\"\n        });\n        const pass2 = await (0, $bXzvz$inquirerprompts.password)({\n            message: \"Enter pass phrase again to confirm\"\n        });\n        if (pass1 === pass2) break;\n        console.error(\"Passwords do not match\");\n    }\n    const client = await (0, $9f203e569b1fab49$export$1f2bb630327ac4b6).generateClient(new (0, $fec366f672fe5d29$export$8688904fb0eaa63d)(), pass1);\n    const filename = `grid-${await client.getThumbprint()}.jws.txt`;\n    client.subscribe((0, ($parcel$interopDefault($bXzvz$lodashdebounce)))(async ()=>{\n        const backup = await client.makeBackup(pass1);\n        await (0, $bXzvz$fs.promises).writeFile(filename, backup);\n    }, 500));\n    // eslint-disable-next-line no-constant-condition\n    while(true)await (0, $50dcff3ae6a8aa6d$export$6dcc8f92a4b45952)(client);\n}\n$a09f43455a860df9$var$main();\n\n\n//# sourceMappingURL=index.js.map\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { password, rawlist, select } from \"@inquirer/prompts\";\nimport * as path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { Client } from \"../client\";\nimport { GridStorage } from \"../client/GridStorage\";\nimport { SignedBackup } from \"../client/types\";\nimport crypto from \"crypto\";\nimport debounce from \"lodash.debounce\";\nimport { mainClientMenu } from \"./mainClientMenu\";\n\nglobal.window ??= {} as any;\n// @ts-expect-error The main target of the project is browsers, so it relies on window.crypto\nwindow.crypto = crypto;\n\nasync function main() {\n  console.clear();\n  const files = await fs.readdir(\".\");\n  const jwsTxtFiles = files.filter((file) => file.endsWith(\".jws.txt\"));\n\n  if (jwsTxtFiles.length > 0) {\n    const filename = await rawlist({\n      message: \"Which file would you like to open?\",\n      choices: [\n        ...jwsTxtFiles.map((file) => ({\n          name: path.basename(file, \".jws.txt\"),\n          value: file,\n        })),\n        { value: \"newIdentity\", name: \"Create a new identity\" },\n      ],\n    });\n    if (filename === \"newIdentity\") {\n      return makeNewIdentity();\n    }\n\n    const pass = await password({\n      message: \"Enter pass phrase to decrypt file\",\n    });\n    const backup = (await fs.readFile(filename, \"utf-8\")) as SignedBackup;\n    try {\n      const client = await Client.loadFromBackup(\n        new GridStorage(),\n        backup,\n        pass\n      );\n      client.subscribe(\n        debounce(async () => {\n          const backup = await client.makeBackup(pass);\n          await fs.writeFile(filename, backup);\n        }, 500)\n      );\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        await mainClientMenu(client);\n      }\n    } catch (e) {\n      console.error(\"Error loading backup\", e);\n      process.exit(1);\n    }\n  } else {\n    const newIdentity = await select({\n      message:\n        \"No backup files found. Would you like to create a new identity?\",\n      choices: [\n        { name: \"Yes\", value: \"yes\" },\n        { name: \"No\", value: \"no\" },\n      ],\n    });\n\n    if (newIdentity === \"no\") {\n      process.exit(0);\n    }\n    return makeNewIdentity();\n  }\n}\n\nasync function makeNewIdentity() {\n  let pass1 = \"\";\n  for (let tries = 0; tries < 3; tries++) {\n    pass1 = await password({\n      message: \"Enter pass phrase to encrypt your new identity\",\n    });\n    const pass2 = await password({\n      message: \"Enter pass phrase again to confirm\",\n    });\n    if (pass1 === pass2) {\n      break;\n    }\n    console.error(\"Passwords do not match\");\n  }\n\n  const client = await Client.generateClient(new GridStorage(), pass1);\n  const filename = `grid-${await client.getThumbprint()}.jws.txt`;\n  client.subscribe(\n    debounce(async () => {\n      const backup = await client.makeBackup(pass1);\n      await fs.writeFile(filename, backup);\n    }, 500)\n  );\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    await mainClientMenu(client);\n  }\n}\n\nmain();\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { GridStorage, ThreadID } from \"./GridStorage\";\nimport {\n  SignedInvitation,\n  Invitation,\n  SelfEncrypted,\n  ReplyMessage,\n  SignedReply,\n  SignedBackup,\n  ReplyToInvite,\n  Decrypted,\n  SignedSelfEncrypted,\n  ReplyToInvitePayload,\n  ReplyPayload,\n  SignedTransport,\n  BackupPayload,\n  UnpackTaggedString,\n  SignedReplyToInvite,\n} from \"./types\";\nimport {\n  generateECDSAKeyPair,\n  generateECDHKeyPair,\n  exportKeyPair,\n  encryptPrivateKey,\n  getJWKthumbprint,\n  invariant,\n  decryptPrivateKey,\n  importKeyPair,\n  parseJWS,\n  deriveSharedSecret,\n  signJWS,\n  verifyJWS,\n  JWK,\n  ECDHCryptoKeyPair,\n  ECDSACryptoKeyPair,\n  exportKey,\n  Thumbprint,\n  SymmetricKey,\n  importPrivateKey,\n  importPublicKey,\n  decryptData,\n  encryptData,\n  parseJWSSync,\n} from \"./utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\nimport { synAck } from \"./synAck\";\n\nconst keyNicknames = new Map<string, string>();\nexport function setNickname(key: string, nickname: string) {\n  keyNicknames.set(key, nickname);\n}\n\nexport function getNickname(key: string) {\n  return keyNicknames.get(key) + \"_\" + key.substring(key.length - 6);\n}\n\nlet messageIdForInviteTesting: number | undefined;\nexport function setMessageIdForTesting(messageId: number) {\n  messageIdForInviteTesting = messageId;\n}\n\nconst MAX_MESSAGE_ID = Number.MAX_SAFE_INTEGER / 2;\n\nexport type DecryptedMessageType = {\n  message: string;\n  type: \"invite\" | \"message\";\n  from: string;\n  fromThumbprint: Thumbprint<\"ECDSA\">;\n  iat: number;\n  messageId: string;\n  minAck: string | undefined;\n  epkThumbprint: Thumbprint<\"ECDH\">;\n  relay?: string;\n};\n\n/**\n * In order to use the client over a websocket connection, everything on it\n * should be async functions. They also can't be arrow functions, because the\n * proxy is looking at the prototype to figure out if there is a function to\n * call.\n */\nexport class Client {\n  public isLocalClient = true; // The proxy will override this\n  private clientNickname: string = Math.random().toString(36).slice(2);\n  async setClientNickname(nickname: string) {\n    this.clientNickname = nickname;\n    if (nickname) {\n      setNickname(this.thumbprint, this.clientNickname!);\n      setNickname(\n        await getJWKthumbprint(await exportKey(this.storageKeyPair.publicKey)),\n        `storage[${this.clientNickname!}]`\n      );\n    }\n  }\n\n  constructor(\n    private storage: GridStorage,\n    private readonly thumbprint: Thumbprint<\"ECDSA\">,\n    private readonly identityKeyPair: ECDSACryptoKeyPair,\n    private readonly storageKeyPair: ECDHCryptoKeyPair\n  ) {}\n\n  async getThumbprint() {\n    return this.thumbprint;\n  }\n\n  static async generateClient(\n    storage: GridStorage,\n    password: string\n  ): Promise<Client> {\n    const identity = await generateECDSAKeyPair();\n    const storageKey = await generateECDHKeyPair();\n    const idJWKs = await exportKeyPair(identity);\n    const storageJWKs = await exportKeyPair(storageKey);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n\n    const thumbprint = await getJWKthumbprint(idJWKs.publicKeyJWK);\n\n    storage.setItem(`identity:${thumbprint}`, {\n      id: {\n        jwk: idJWKs.publicKeyJWK,\n        private: encryptedIdentity,\n      },\n      storage: {\n        jwk: storageJWKs.publicKeyJWK,\n        private: encryptedStorageKey,\n      },\n    });\n\n    return Client.loadClient(storage, thumbprint, password);\n  }\n\n  static async loadFromBackup(\n    storage: GridStorage,\n    backup: BackupPayload | SignedBackup,\n    password: string\n  ): Promise<Client> {\n    if (typeof backup === \"string\") {\n      const jws = await parseJWS(backup);\n      return Client.loadFromBackup(storage, jws.payload, password);\n    }\n\n    const identityPrivateKey = await decryptPrivateKey(\n      backup.identity.id.private,\n      password\n    );\n    const storagePrivateKey = await decryptPrivateKey(\n      backup.identity.storage.private,\n      password\n    );\n\n    const identityKeyPair: ECDSACryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: identityPrivateKey,\n        publicKeyJWK: backup.identity.id.jwk,\n      },\n      \"ecdsa\"\n    );\n    const storageKeyPair: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: storagePrivateKey,\n        publicKeyJWK: backup.identity.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    await storage.loadIdentityBackup(backup);\n    const client = new Client(\n      storage,\n      backup.thumbprint,\n      identityKeyPair,\n      storageKeyPair\n    );\n    return client;\n  }\n\n  static async loadClient(\n    storage: GridStorage,\n    thumbprint: Thumbprint<\"ECDSA\">,\n    password: string\n  ) {\n    const storedData = storage.getItem(`identity:${thumbprint}`);\n    invariant(storedData, \"No identity found for thumbprint\");\n\n    const privateKeyJWK = await decryptPrivateKey(\n      storedData.id.private,\n      password\n    );\n    const id = await importKeyPair(\n      { privateKeyJWK, publicKeyJWK: storedData.id.jwk },\n      \"ecdsa\"\n    );\n\n    const storageKeys: ECDHCryptoKeyPair = await importKeyPair(\n      {\n        privateKeyJWK: await decryptPrivateKey(\n          storedData.storage.private,\n          password\n        ),\n        publicKeyJWK: storedData.storage.jwk,\n      },\n      \"ecdh\"\n    );\n\n    return new Client(storage, thumbprint, id, storageKeys);\n  }\n\n  async decryptFromSelf(message: SignedSelfEncrypted): Promise<string> {\n    const selfEncrypted = await parseJWS(\n      message,\n      this.identityKeyPair.publicKey\n    );\n\n    const epk = await importPublicKey(\"ECDH\", selfEncrypted.header.epk);\n\n    const secret = await deriveSharedSecret(\n      this.storageKeyPair.privateKey,\n      epk\n    );\n    const payload = await decryptData(\n      secret,\n      selfEncrypted.header.iv,\n      selfEncrypted.payload\n    );\n    return payload;\n  }\n  async encryptToSelf(message: string) {\n    const epk = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(epk);\n\n    const secret = await deriveSharedSecret(\n      epk.privateKey,\n      this.storageKeyPair.publicKey\n    );\n    const { iv, encrypted } = await encryptData(secret, message);\n\n    const selfEncrypted: SelfEncrypted = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"self-encrypted\",\n        iv,\n        epk: jwks.publicKeyJWK,\n      },\n      payload: encrypted,\n    };\n\n    const encryptedJWS = (await signJWS(\n      selfEncrypted.header,\n      selfEncrypted.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedSelfEncrypted;\n    // try {\n    invariant(await verifyJWS(encryptedJWS), \"Error encrypting message\");\n    const decryptedMessage = await this.decryptFromSelf(encryptedJWS);\n    invariant(decryptedMessage, \"Decrypted message is empty\");\n    invariant(\n      decryptedMessage === message ||\n        message === JSON.stringify(decryptedMessage),\n      \"Decrypted message mismatch\"\n    );\n    // } catch (e: any) {\n    //   throw new Error(`Error encrypting message: ${e?.message ?? e}`);\n    // }\n\n    return encryptedJWS;\n  }\n\n  async createInvitation({\n    note,\n    nickname,\n  }: {\n    note?: string;\n    nickname: string;\n  }): Promise<SignedInvitation> {\n    const { thumbprint, jwks } = await this.makeThreadKeys();\n\n    const invitation: Invitation = {\n      header: {\n        alg: \"ES384\",\n        jwk: (await exportKeyPair(this.identityKeyPair)).publicKeyJWK,\n        iat: 0,\n        sub: \"grid-invitation\",\n      },\n      payload: {\n        messageId: Number(\n          messageIdForInviteTesting ??\n            Math.floor(Math.random() * MAX_MESSAGE_ID)\n        ).toString(16),\n        epk: jwks.publicKeyJWK,\n        note,\n        nickname,\n      },\n    };\n    const signedInvitation = (await signJWS(\n      invitation.header,\n      invitation.payload,\n      this.identityKeyPair.privateKey\n    )) as SignedInvitation;\n\n    this.storage.setItem(`invitation:${thumbprint}`, signedInvitation);\n    this.storage.appendItem(`invitations:${this.thumbprint}`, thumbprint, {\n      unique: true,\n    });\n    this.storage.setItem(\n      `threads:${this.thumbprint}`,\n      this.storage.queryItem(`threads:${this.thumbprint}`) ?? []\n    );\n    this.notifySubscribers();\n    return signedInvitation;\n  }\n\n  async replyToInvitation(\n    signedInvite: SignedInvitation,\n    message: string,\n    nickname: string,\n    { setMyRelay }: { setMyRelay?: string } = {}\n  ) {\n    invariant(await verifyJWS(signedInvite), \"Invalid invitation signature\");\n    const invite = await parseJWS(signedInvite);\n\n    const threadId = await this.startThread(\n      signedInvite,\n      invite.payload.epk,\n      invite.header.jwk\n    );\n    const reply = this.replyToThread(threadId, message, {\n      selfSign: true,\n      nickname,\n      setMyRelay,\n    });\n    return reply;\n  }\n\n  private async startThread(\n    signedInvite: SignedInvitation,\n    theirEPKJWK: JWK<\"ECDH\", \"public\">,\n    theirSignature: JWK<\"ECDSA\", \"public\">,\n    myThumbprint?: Thumbprint<\"ECDH\">\n  ): Promise<ThreadID> {\n    if (!myThumbprint) {\n      const { thumbprint } = await this.makeThreadKeys();\n      myThumbprint = thumbprint;\n    }\n    const keyBackup = this.storage.getItem(\n      `encrypted-thread-key:${myThumbprint}`\n    );\n    invariant(keyBackup, `Thread key not found ${myThumbprint}`);\n\n    const signatureThumbprint = await getJWKthumbprint(theirSignature);\n    invariant(\n      !myThumbprint || signatureThumbprint !== this.thumbprint,\n      \"Cannot start a thread with yourself\"\n    );\n\n    const thumbprints: Thumbprint<\"ECDH\">[] = [\n      await getJWKthumbprint(theirEPKJWK),\n      myThumbprint,\n    ].sort();\n\n    const threadId = ArrayBuffertohex(\n      await window.crypto.subtle.digest(\n        \"SHA-256\",\n        Buffer.from(thumbprints.join(\":\"))\n      )\n    ) as ThreadID;\n\n    this.storage.setItem(`thread-info:${this.thumbprint}:${threadId}`, {\n      missing: [],\n      windowSize: 5,\n      maxAck: undefined,\n      minAck: undefined,\n      syn: undefined,\n      myThumbprint,\n      theirEPK: theirEPKJWK,\n      signedInvite,\n      theirSignature,\n      relays: {},\n    });\n    this.storage.appendItem(`threads:${this.thumbprint}`, threadId);\n    await this.appendThread(signedInvite, threadId);\n\n    this.notifySubscribers();\n\n    return threadId;\n  }\n\n  async getThreads(): Promise<ThreadID[]> {\n    return this.storage.queryItem(`threads:${this.thumbprint}`) ?? [];\n  }\n  async getInvitationIds() {\n    return this.storage.queryItem(`invitations:${this.thumbprint}`) ?? [];\n  }\n  async getInvitations() {\n    return (await this.getInvitationIds()).map(\n      (t) => this.storage.getItem(`invitation:${t}`)!\n    );\n  }\n\n  async getInvitation(thumbprint: Thumbprint<\"ECDH\">) {\n    return this.storage.getItem(`invitation:${thumbprint}`);\n  }\n\n  private async makeThreadKeys() {\n    const threadKey = await generateECDHKeyPair();\n    const jwks = await exportKeyPair(threadKey);\n    const thumbprint = await getJWKthumbprint(jwks.publicKeyJWK);\n    setNickname(thumbprint, `thread[${this.clientNickname}]`);\n    const keyBackup = await this.encryptToSelf(JSON.stringify(jwks));\n    this.storage.setItem(`encrypted-thread-key:${thumbprint}`, keyBackup);\n\n    return { thumbprint, jwks };\n  }\n\n  private async readThreadSecret(threadThumbprint: ThreadID): Promise<{\n    secret: SymmetricKey;\n    epk: JWK<\"ECDH\", \"public\">;\n  }> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadThumbprint}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n\n    const publicJWK = threadInfo.theirEPK;\n    invariant(publicJWK, `Public key not found ${threadInfo.theirEPK}`);\n\n    const encryptedBackup = this.storage.getItem(\n      `encrypted-thread-key:${threadInfo.myThumbprint}`\n    );\n    invariant(\n      typeof encryptedBackup === \"string\",\n      `Thread key not found ${threadInfo.myThumbprint}`\n    );\n\n    type JWKPair = {\n      privateKeyJWK: JWK<\"ECDH\", \"private\">;\n      publicKeyJWK: JWK<\"ECDH\", \"public\">;\n    };\n    const jwks: JWKPair = JSON.parse(\n      await this.decryptFromSelf(encryptedBackup)\n    );\n    const pKey = await importPublicKey(\"ECDH\", publicJWK);\n    const privateKey = await importPrivateKey(\"ECDH\", jwks.privateKeyJWK);\n\n    return {\n      secret: await deriveSharedSecret(privateKey, pKey),\n      epk: jwks.publicKeyJWK,\n    };\n  }\n\n  public async replyToThread(\n    threadId: ThreadID,\n    message: string,\n    options?: {\n      selfSign?: boolean;\n      nickname?: string;\n      setMyRelay?: string;\n    }\n  ): Promise<{\n    reply: SignedReply;\n    threadId: ThreadID;\n    relay?: string;\n  }> {\n    const { secret, epk } = await this.readThreadSecret(threadId);\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const messageId =\n      threadInfo.syn ??\n      Number(\n        messageIdForInviteTesting\n          ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n          : Math.floor(Math.random() * MAX_MESSAGE_ID)\n      ).toString(16);\n    invariant(typeof messageId === \"string\", `Invalid message id ${messageId}`);\n    const nextId = incMessageId(messageId);\n    if (options?.setMyRelay) {\n      threadInfo.relays[this.thumbprint] = options.setMyRelay;\n    }\n\n    invariant(threadInfo.minAck, `Missing minAck in \"thread-info\" ${message}`);\n    let replyMessage: Decrypted<ReplyMessage | ReplyToInvite> = {\n      header: {\n        iat: 0,\n        alg: \"ES384\",\n        sub: \"grid-reply\",\n        re: threadId,\n        iv: \"\",\n        from: this.thumbprint,\n      },\n      payload: {\n        messageId: nextId,\n        message,\n        minAck: threadInfo.minAck,\n      },\n    };\n    // threadInfo.syn = nextId;\n    this.storage.setItem(\n      `thread-info:${this.thumbprint}:${threadId}`,\n      threadInfo\n    );\n    if (options?.selfSign && options.nickname) {\n      const ack: Decrypted<ReplyToInvite> = {\n        header: {\n          ...replyMessage.header,\n          sub: \"reply-to-invite\",\n          jwk: await exportKey(this.identityKeyPair.publicKey),\n          invite: await getJWKthumbprint(threadInfo.theirEPK),\n          epk,\n        },\n        payload: {\n          ...replyMessage.payload,\n          nickname: options.nickname,\n          messageId: Number(\n            messageIdForInviteTesting\n              ? parseInt(\"100000\", 16) + messageIdForInviteTesting\n              : Math.floor(Math.random() * MAX_MESSAGE_ID)\n          ).toString(16),\n        },\n      };\n      replyMessage = ack;\n    }\n    if (options?.setMyRelay) {\n      replyMessage.payload.relay = options.setMyRelay;\n    }\n\n    const { iv, encrypted } = await encryptData(secret, replyMessage.payload);\n    replyMessage.header.iv = iv;\n    const encryptedJWS = (await signJWS(\n      replyMessage.header,\n      encrypted,\n      this.identityKeyPair.privateKey\n    )) as SignedReply;\n\n    invariant(\n      verifyJWS(encryptedJWS, this.identityKeyPair.publicKey),\n      \"Error encrypting message\"\n    );\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const relay = threadInfo.relays[theirThumbprint];\n\n    await this.appendThread(encryptedJWS, threadId);\n    return {\n      reply: encryptedJWS,\n      threadId,\n      relay,\n    };\n  }\n\n  public async appendThread(\n    encryptedMessage: SignedTransport,\n    threadId?: ThreadID\n  ): Promise<{\n    threadId: ThreadID;\n    message: {\n      message: string;\n      type: \"invite\" | \"message\";\n    };\n    relay?: string;\n  }> {\n    const jws = parseJWSSync(encryptedMessage);\n    if (!threadId) {\n      switch (jws.header.sub) {\n        case \"grid-invitation\": {\n          // const invite = jws as Invitation;\n          throw new Error(\"Not Implemented\");\n          break;\n        }\n        case \"reply-to-invite\": {\n          const isValid = verifyJWS(encryptedMessage);\n          invariant(isValid, \"Expected a self-signed message\");\n          const reply = jws as ReplyToInvite;\n          invariant(reply.header.epk, \"First message must have an epk\");\n          invariant(\n            reply.header.invite,\n            'First message must have an \"invite\" header'\n          );\n          const invitationThumbprint = reply.header.invite;\n          const invitation = this.storage.getItem(\n            `invitation:${invitationThumbprint}`\n          );\n          invariant(invitation, \"Invitation not found \" + invitationThumbprint);\n          const invitationJWS = await parseJWS(invitation);\n\n          const myThumbprint = await getJWKthumbprint(\n            invitationJWS.payload.epk\n          );\n          threadId = await this.startThread(\n            invitation,\n            reply.header.epk,\n            reply.header.jwk,\n            myThumbprint\n          );\n          // FALLS THROUGH\n        }\n        case \"grid-reply\": {\n          const reply = jws as ReplyMessage;\n          threadId ??= reply.header.re;\n          const threadInfo = this.storage.getItem(\n            `thread-info:${this.thumbprint}:${threadId}`\n          );\n\n          const fromMe = reply.header.from === this.thumbprint;\n          let isValid = false;\n          if (fromMe) {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              this.identityKeyPair.publicKey\n            );\n          } else {\n            isValid = await verifyJWS(\n              encryptedMessage,\n              threadInfo.theirSignature\n            );\n          }\n          invariant(isValid, \"Invalid message signature\");\n\n          return this.appendThread(encryptedMessage, threadId);\n        }\n      }\n    }\n    invariant(threadId, \"Thread not found\");\n    const message = await this.decryptMessage(threadId, encryptedMessage);\n    const threadInfo = {\n      ...this.storage.getItem(`thread-info:${this.thumbprint}:${threadId}`),\n    };\n\n    const fromMe = message.fromThumbprint === this.thumbprint;\n\n    let isValid;\n    if (fromMe) {\n      isValid = await verifyJWS(\n        encryptedMessage,\n        this.identityKeyPair.publicKey\n      );\n    } else {\n      isValid = await verifyJWS(encryptedMessage, threadInfo.theirSignature);\n    }\n    invariant(isValid, \"Invalid message signature\");\n    const storeMessage = synAck(\n      fromMe\n        ? {\n            syn: message.messageId,\n          }\n        : {\n            ack: message.messageId,\n          },\n      threadInfo\n    );\n\n    if (storeMessage) {\n      const m = this.storage.queryItem(\n        `keyed-messages:${this.thumbprint}:${threadId}`\n      )?.messages;\n      invariant(\n        m ? !m.includes(encryptedMessage) : true,\n        // m?.[0] !== encryptedMessage || lastMessage !== encryptedMessage,\n        `Message already exists in thread ${JSON.stringify(\n          {\n            nickname: this.clientNickname,\n            messageId: message.messageId,\n            sub: jws.header.sub,\n            threadId,\n            messageIndex: m?.indexOf(encryptedMessage),\n          },\n          null,\n          2\n        )}`\n      );\n      if (message.relay) {\n        threadInfo.relays[await getJWKthumbprint(threadInfo.theirSignature)] =\n          message.relay;\n\n        if (\n          message.relay &&\n          message.relay.match(/^https?:\\/\\/ntfy.sh\\/[^.]+$/)\n        ) {\n          threadInfo.relays[this.thumbprint] = message.relay;\n        }\n      }\n      this.storage.setItem(\n        `thread-info:${this.thumbprint}:${threadId}`,\n        threadInfo\n      );\n      this.storage.storeMessage(\n        this.thumbprint,\n        threadId,\n        message.messageId,\n        encryptedMessage\n      );\n      this.notifySubscribers();\n    } else {\n      console.warn(\"Skipping message\", message.messageId);\n    }\n    return {\n      threadId: threadId,\n      message,\n      relay: message.relay,\n    };\n  }\n\n  public async decryptThread(threadId: ThreadID) {\n    const thread = await this.getEncryptedThread(threadId);\n    const messages = await Promise.all(\n      thread.map(async (message) => {\n        return typeof message === \"string\"\n          ? this.decryptMessage(threadId, message)\n          : message;\n      })\n    );\n    messages.sort((a, b) => {\n      if (a.from !== b.from) {\n        if (a.minAck && a.minAck < b.messageId) {\n          return 1;\n        }\n        if (b.minAck && b.minAck < a.messageId) {\n          return 1;\n        }\n      }\n      const order =\n        (a.type === \"invite\" ? -1 : 0) ||\n        (b.type === \"invite\" ? 1 : 0) ||\n        b.iat - a.iat ||\n        (a.from === b.from ? a.messageId.localeCompare(b.messageId) : 0);\n\n      return order;\n    });\n    return messages;\n  }\n  public async decryptMessage(\n    threadId: ThreadID,\n    encryptedMessage: SignedTransport\n  ): Promise<DecryptedMessageType> {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${threadId}`\n    );\n    const jws = await parseJWS(encryptedMessage, null);\n    invariant(threadInfo, \"Thread not found\");\n\n    if (jws.header.sub === \"grid-invitation\") {\n      // Looks like an Invite\n      invariant(await verifyJWS(encryptedMessage), \"Invalid message signature\");\n      const jwsInvite: Invitation = jws as Invitation;\n\n      const message = `Invite from ${jwsInvite.payload.nickname}.\\nNote: ${\n        jwsInvite.payload.note ?? \"(none)\"\n      }`;\n\n      const from = await getJWKthumbprint(jwsInvite.header.jwk);\n      if (jwsInvite.payload.nickname) {\n        setNickname(from, jwsInvite.payload.nickname);\n      }\n      return {\n        from: getNickname(from),\n        fromThumbprint: from,\n        epkThumbprint: await getJWKthumbprint(jwsInvite.payload.epk),\n        message,\n        type: \"invite\",\n        iat: jwsInvite.header.iat,\n        messageId: jwsInvite.payload.messageId,\n        minAck: undefined,\n      };\n    }\n    const reply = jws as ReplyMessage | ReplyToInvite;\n    const { secret } = await this.readThreadSecret(threadId);\n    const payload = await decryptData<ReplyToInvitePayload | ReplyPayload>(\n      secret,\n      jws.header.iv,\n      reply.payload\n    );\n    const from = reply.header.from;\n\n    const theirThumbprint = await getJWKthumbprint(threadInfo.theirSignature);\n    const epkThumbprint =\n      from === theirThumbprint\n        ? await getJWKthumbprint(threadInfo.theirEPK)\n        : threadInfo.myThumbprint;\n\n    return {\n      from: getNickname(from),\n      fromThumbprint: from,\n      epkThumbprint,\n      message: payload.message,\n      type: \"message\",\n      iat: reply.header.iat,\n      messageId: payload.messageId,\n      minAck: payload.minAck,\n      relay: payload.relay,\n    };\n  }\n\n  public async getEncryptedThread(threadId: ThreadID) {\n    return this.storage.readMessages(this.thumbprint, threadId);\n  }\n\n  public async getThreadInfo(thread: ThreadID) {\n    const threadInfo = this.storage.getItem(\n      `thread-info:${this.thumbprint}:${thread}`\n    );\n    invariant(threadInfo, \"Thread not found\");\n    const myRelay = threadInfo.relays[this.thumbprint];\n\n    return {\n      myRelay,\n      myNickname: getNickname(this.thumbprint),\n      theirNickname: getNickname(\n        await getJWKthumbprint(threadInfo.theirSignature)\n      ),\n    };\n  }\n\n  async makeBackup(password: string) {\n    const idJWKs = await exportKeyPair(this.identityKeyPair);\n    const storageJWKs = await exportKeyPair(this.storageKeyPair);\n\n    const encryptedIdentity = await encryptPrivateKey(\n      idJWKs.privateKeyJWK,\n      password\n    );\n    const encryptedStorageKey = await encryptPrivateKey(\n      storageJWKs.privateKeyJWK,\n      password\n    );\n    const payload = await this.storage.makeIdentityBackup(\n      this.thumbprint,\n      encryptedIdentity,\n      encryptedStorageKey\n    );\n\n    return signJWS(\n      {\n        alg: \"ES384\",\n        jwk: idJWKs.publicKeyJWK,\n      },\n      payload,\n      this.identityKeyPair.privateKey\n    ) as Promise<SignedBackup>;\n  }\n\n  private notifySubscribers() {\n    for (const sub of this.subscriptions) {\n      try {\n        sub?.();\n      } catch (e) {\n        // Ignore\n      }\n    }\n  }\n  private subscriptions = new Set<() => void>();\n  public subscribe(onChange: () => void) {\n    this.subscriptions ??= new Set<() => void>();\n    this.subscriptions.add(onChange);\n\n    return () => {\n      this.subscriptions.delete(onChange);\n    };\n  }\n}\n\nexport function incMessageId(messageId: string) {\n  let nextId = parseInt(messageId, 16) + 1;\n  if (nextId >= MAX_MESSAGE_ID) {\n    nextId = 1;\n  }\n  invariant(!Number.isNaN(nextId), `Invalid message id ${messageId} ${nextId}`);\n  const n = nextId.toString(16);\n  invariant(\n    !Number.isNaN(n),\n    `Invalid message toString ${messageId} ${nextId}`\n  );\n  return n;\n}\n\nexport type {\n  BackupPayload,\n  Invitation,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedTransport,\n  Thumbprint,\n  ThreadID,\n  UnpackTaggedString,\n};\nexport { GridStorage };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  BackupPayload,\n  SignedInvitation,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n  ThreadInfoData,\n} from \"./types\";\nimport { EncryptedPrivateKey, invariant, JWK, Thumbprint } from \"./utils\";\n\nexport type ThreadID = TaggedString<\"ThreadID\">;\n\ntype Key<Type extends StoredDataTypes[\"type\"]> = `${Type}:${Extract<\n  StoredDataTypes,\n  { type: Type }\n>[\"keyType\"]}`;\nexport type GridStorageType = {\n  hasItem<Type extends StoredDataTypes[\"type\"]>(key: Key<Type>): boolean;\n  removeItem: <Type extends StoredDataTypes[\"type\"]>(key: Key<Type>) => null;\n  queryItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"] | null;\n  getItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>\n  ) => Extract<StoredDataTypes, { type: Type }>[\"data\"];\n  setItem: <Type extends StoredDataTypes[\"type\"]>(\n    key: Key<Type>,\n    value: Extract<StoredDataTypes, { type: Type }>[\"data\"]\n  ) => void;\n  appendItem: <\n    Type extends StoredDataTypes[\"type\"],\n    V extends Extract<StoredDataTypes, { type: Type }>[\"data\"]\n  >(\n    key: Key<Type>,\n    value: V extends Array<any> ? V[number] : never,\n    options?: { unique?: boolean }\n  ) => void;\n};\nexport type StoredIdentity = {\n  id: {\n    jwk: JWK<\"ECDSA\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDSA\">;\n  };\n  storage: {\n    jwk: JWK<\"ECDH\", \"public\">;\n    private: EncryptedPrivateKey<\"ECDH\">;\n  };\n};\n\ntype StoredDataTypes =\n  | {\n      type: \"identity\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: StoredIdentity;\n    }\n  | {\n      type: \"thread-info\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: ThreadInfoData;\n    }\n  | { type: \"invitation\"; keyType: Thumbprint<\"ECDH\">; data: SignedInvitation }\n  | {\n      type: \"invitations\";\n      keyType: Thumbprint<\"ECDSA\">;\n      data: Thumbprint<\"ECDH\">[];\n    }\n  | {\n      type: \"keyed-messages\";\n      keyType: `${Thumbprint<\"ECDSA\">}:${ThreadID}`;\n      data: {\n        min: string;\n        max: string;\n        messages: Array<SignedTransport>;\n      };\n    }\n  | {\n      type: \"encrypted-thread-key\";\n      keyType: Thumbprint<\"ECDH\">;\n      data: SignedSelfEncrypted;\n    }\n  | { type: \"threads\"; keyType: Thumbprint<\"ECDSA\">; data: Array<ThreadID> };\n\nexport class GridStorage implements GridStorageType {\n  protected data: {\n    get: (key: string) => any;\n    has: (key: string) => boolean;\n    delete: (key: string) => void;\n    set: (key: string, value: any) => void;\n  } = new Map<string, any>();\n\n  debugData() {\n    return Object.fromEntries((this.data as any).entries());\n  }\n\n  async loadIdentityBackup(backup: BackupPayload) {\n    this.setItem(`identity:${backup.thumbprint}`, backup.identity);\n    Object.entries(backup.invites ?? {}).forEach(([key, value]) => {\n      this.appendItem(\n        `invitations:${backup.thumbprint}`,\n        key as Thumbprint<\"ECDH\">,\n        { unique: true }\n      );\n      this.setItem(`invitation:${key as Thumbprint<\"ECDH\">}`, value);\n    });\n    Object.entries(backup.encryptedThreadKeys).forEach(([thumbprint, key]) => {\n      this.setItem(\n        `encrypted-thread-key:${thumbprint as Thumbprint<\"ECDH\">}`,\n        key\n      );\n    });\n    Object.entries(backup.threads).forEach(([id, thread]) => {\n      const threadId = id as ThreadID;\n      this.appendItem(`threads:${backup.thumbprint}`, threadId);\n      this.setItem(\n        `thread-info:${backup.thumbprint}:${threadId}`,\n        thread.threadInfo\n      );\n      this.setItem(\n        `keyed-messages:${backup.thumbprint}:${threadId}`,\n        thread.messages\n      );\n    });\n  }\n\n  async makeIdentityBackup(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    idPrivateKey: EncryptedPrivateKey<\"ECDSA\">,\n    storagePrivateKey: EncryptedPrivateKey<\"ECDH\">\n  ): Promise<BackupPayload> {\n    const identity = this.getItem(`identity:${thumbprint}`);\n    const encryptedThreadKeys: BackupPayload[\"encryptedThreadKeys\"] = {};\n\n    return {\n      thumbprint,\n      identity: {\n        id: {\n          jwk: identity.id.jwk,\n          private: idPrivateKey,\n        },\n        storage: {\n          jwk: identity.storage.jwk,\n          private: storagePrivateKey,\n        },\n      },\n      invites: this.queryItem(`invitations:${thumbprint}`)?.reduce(\n        (memo, key) => {\n          memo[key] = this.getItem(`invitation:${key}`);\n\n          encryptedThreadKeys[key] = this.getItem(\n            `encrypted-thread-key:${key}`\n          );\n          return memo;\n        },\n        {} as NonNullable<BackupPayload[\"invites\"]>\n      ),\n      threads:\n        (await this.queryItem(`threads:${thumbprint}`)?.reduce(\n          async (m, key) => {\n            const memo = await m;\n            const threadInfo = this.getItem(`thread-info:${thumbprint}:${key}`);\n            const messages = this.getItem(\n              `keyed-messages:${thumbprint}:${key}`\n            );\n            encryptedThreadKeys[threadInfo.myThumbprint] = this.getItem(\n              `encrypted-thread-key:${threadInfo.myThumbprint}`\n            );\n\n            memo[key] = {\n              threadInfo,\n              messages,\n            };\n            return memo;\n          },\n          Promise.resolve({} as NonNullable<BackupPayload[\"threads\"]>)\n        )) ?? {},\n\n      encryptedThreadKeys,\n    };\n  }\n\n  hasItem: GridStorageType[\"hasItem\"] = (key) => {\n    return this.data.has(key);\n  };\n\n  removeItem: GridStorageType[\"removeItem\"] = (key) => {\n    this.data.delete(key);\n    return null;\n  };\n\n  queryItem: GridStorageType[\"queryItem\"] = (key) => {\n    return this.data.get(key);\n  };\n\n  getItem: GridStorageType[\"getItem\"] = (key) => {\n    invariant(this.hasItem(key), `Key ${key} not found in storage.`);\n    return this.data.get(key);\n  };\n\n  setItem: GridStorageType[\"setItem\"] = (key, value) => {\n    this.data.set(key, value);\n  };\n\n  appendItem: GridStorageType[\"appendItem\"] = (\n    key,\n    value,\n    { unique = false } = {}\n  ) => {\n    let arr: any = this.queryItem(key);\n    if (!Array.isArray(arr)) {\n      arr = [];\n    }\n    if (unique && arr.includes(value)) {\n      return;\n    }\n    arr.push(value);\n    this.setItem(key, arr);\n  };\n\n  public storeMessage(\n    thumbprint: Thumbprint<\"ECDSA\">,\n    threadId: ThreadID,\n    messageId: string,\n    message: SignedTransport\n  ) {\n    const index = this.queryItem(\n      `keyed-messages:${thumbprint}:${threadId}`\n    ) ?? {\n      min: messageId,\n      max: messageId,\n      messages: [] as SignedTransport[],\n    };\n    index.messages.push(message);\n    this.setItem(`keyed-messages:${thumbprint}:${threadId}`, index);\n  }\n  public readMessages(thumbprint: Thumbprint<\"ECDSA\">, threadId: ThreadID) {\n    const { messages } = this.getItem(\n      `keyed-messages:${thumbprint}:${threadId}`\n    );\n    return messages;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  utf8tob64u,\n  hextob64u,\n  ArrayBuffertohex,\n  b64utoutf8,\n  hextoArrayBuffer,\n  b64utohex,\n  rstrtohex,\n} from \"jsrsasign\";\nimport { setNickname } from \"./index\";\nimport {\n  BackupJWS,\n  Encrypted,\n  Invitation,\n  ReplyMessage,\n  ReplyToInvite,\n  SelfEncrypted,\n  SignedBackup,\n  SignedInvitation,\n  SignedReply,\n  SignedReplyToInvite,\n  SignedSelfEncrypted,\n  SignedTransport,\n  TaggedString,\n} from \"./types\";\n\nexport const b64uToBuffer = (str: string) =>\n  Buffer.from(str.replace(\"-\", \"+\").replace(\"_\", \"/\"), \"base64\");\n\nexport const bufferToB64u = (src: Uint8Array | ArrayBuffer) =>\n  Buffer.from(src)\n    .toString(\"base64\")\n    .replace(\"+\", \"-\")\n    .replace(\"/\", \"_\")\n    .replace(\"=\", \"\");\nexport const ecdhAlg = {\n  name: \"ECDH\",\n  namedCurve: \"P-384\",\n} as const;\nexport const ecdsaAlg = {\n  name: \"ECDSA\",\n  namedCurve: \"P-384\",\n} as const;\nconst ecdsaKeyUseages = [\"sign\", \"verify\"] as const;\nexport const ecdsaSignAlg = {\n  name: \"ECDSA\",\n  hash: { name: \"SHA-384\" },\n} as const;\n\nconst keySymbol = Symbol(\"keySymbol\");\ntype Visibility = \"public\" | \"private\";\ntype AlgorithmType = \"ECDSA\" | \"ECDH\";\ntype TaggedKey<T = [AlgorithmType, Visibility]> = CryptoKey & {\n  [keySymbol]: T;\n};\nexport type EncryptedPrivateKey<T = AlgorithmType> = TaggedString<\n  [T, \"private\"]\n>;\nexport type SymmetricKey = CryptoKey & { [keySymbol]: \"AES-GCM\" };\n\nexport type ECDHCryptoKey<V = Visibility> = TaggedKey<[\"ECDH\", V]>;\nexport type ECDSACryptoKey<V = Visibility> = TaggedKey<[\"ECDSA\", V]>;\nexport type TaggedCryptoKeyPair<T = AlgorithmType> = {\n  publicKey: TaggedKey<[T, \"public\"]>;\n  privateKey: TaggedKey<[T, \"private\"]>;\n};\nexport type ECDSACryptoKeyPair = TaggedCryptoKeyPair<\"ECDSA\">;\nexport type ECDHCryptoKeyPair = TaggedCryptoKeyPair<\"ECDH\">;\n\nexport type JWK<T = \"ECDSA\" | \"ECDH\", V = Visibility> = JsonWebKey & {\n  [keySymbol]: [T, V];\n};\nexport type Thumbprint<T = AlgorithmType> = string & {\n  [keySymbol]: T;\n};\n\nexport async function generateECDSAKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(\n    ecdsaAlg,\n    true,\n    ecdsaKeyUseages\n  )) as ECDSACryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDSA`);\n\n  return keyPair;\n}\nexport async function generateECDHKeyPair() {\n  const keyPair = (await window.crypto.subtle.generateKey(ecdhAlg, true, [\n    \"deriveKey\",\n    \"deriveBits\",\n  ])) as ECDHCryptoKeyPair;\n  const thumbprint = await getJWKthumbprint(await exportKey(keyPair.publicKey));\n  setNickname(thumbprint, `${thumbprint}/ECDH`);\n\n  return keyPair;\n}\nexport function invariant<T>(condition: T, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexport async function deriveSharedSecret(\n  privateKey: TaggedKey<[\"ECDH\", \"private\"]>,\n  publicKey: TaggedKey<[\"ECDH\", \"public\"]>\n): Promise<SymmetricKey> {\n  const bits = await window.crypto.subtle.deriveBits(\n    {\n      name: ecdhAlg.name,\n      public: publicKey,\n    },\n    privateKey,\n    256\n  );\n  return (await window.crypto.subtle.importKey(\n    \"raw\",\n    bits,\n    { name: \"AES-GCM\" },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  )) as SymmetricKey;\n}\n\ntype Header = {\n  iat?: number;\n  alg: \"ES384\";\n  jwk?: JWK<any, any>;\n};\nexport async function signJWS<H extends Header = Header, P = object | string>(\n  header: H,\n  payload: P,\n  privateKey: ECDSACryptoKey<\"private\">\n): Promise<string> {\n  const unixTimetsamp = Math.floor(Date.now() / 1000);\n  header.iat = unixTimetsamp;\n\n  const encodedHeader = utf8tob64u(JSON.stringify(header));\n\n  const encodedPayload = utf8tob64u(\n    typeof payload === \"string\" ? payload : JSON.stringify(payload)\n  );\n  const dataToSign = `${encodedHeader}.${encodedPayload}`;\n\n  const signature = await window.crypto.subtle.sign(\n    ecdsaSignAlg,\n    privateKey,\n    new TextEncoder().encode(dataToSign)\n  );\n\n  // Step 5: Encode the signature\n  const encodedSignature = hextob64u(ArrayBuffertohex(signature));\n\n  // Step 6: Concatenate the encoded parts\n  const jws = `${dataToSign}.${encodedSignature}`;\n\n  return jws;\n}\nexport async function verifyJWS(\n  jws: string,\n  pubKey?: ECDSACryptoKey<\"public\"> | JWK<\"ECDSA\", \"public\"> | null\n): Promise<boolean> {\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1);\n  }\n\n  const [header, payload, signature] = jws.split(\".\");\n  const signedData = `${header}.${payload}`;\n\n  if (!pubKey) {\n    let headerObj;\n    try {\n      headerObj = JSON.parse(b64utoutf8(header));\n    } catch (e) {\n      // ignore JSON parse errors\n    }\n    if (headerObj && \"jwk\" in headerObj && typeof headerObj.jwk === \"object\") {\n      const pubKey = await importPublicKey<\"ECDSA\">(\"ECDSA\", headerObj.jwk);\n      return verifyJWS(jws, pubKey);\n    }\n    return false;\n  }\n\n  if (\"kty\" in pubKey) {\n    pubKey = await importPublicKey(\"ECDSA\", pubKey);\n  }\n\n  const isValid = await window.crypto.subtle.verify(\n    { name: ecdsaAlg.name, hash: { name: \"SHA-384\" } },\n    pubKey as CryptoKey,\n    hextoArrayBuffer(b64utohex(signature)),\n    new TextEncoder().encode(signedData)\n  );\n  return isValid;\n}\nexport async function getJWKthumbprint<T = AlgorithmType>(\n  jwk: JWK<T, any>\n): Promise<Thumbprint<T>> {\n  invariant(jwk.kty === \"EC\", \"Unsupported key type\");\n  const s = {\n    crf: jwk.crv,\n    kty: jwk.kty,\n    x: jwk.x,\n    y: jwk.y,\n  };\n  const hex = rstrtohex(JSON.stringify(s));\n  const sha256 = await window.crypto.subtle.digest(\n    \"SHA-256\",\n    hextoArrayBuffer(hex)\n  );\n  const alg = jwk.alg ? `${jwk.alg}/` : \"\";\n\n  return `id-${alg}${hextob64u(ArrayBuffertohex(sha256))}` as any;\n}\n\nexport function exportKey<T = AlgorithmType, V = Visibility>(\n  key: TaggedKey<[T, V]>\n) {\n  return window.crypto.subtle.exportKey(\"jwk\", key) as Promise<JWK<T, V>>;\n}\n\nexport async function exportKeyPair<T = AlgorithmType>(\n  keyPair: TaggedCryptoKeyPair<T>\n) {\n  const privateKeyJWK = await exportKey(keyPair.privateKey);\n  const publicKeyJWK = await exportKey(keyPair.publicKey);\n  return { privateKeyJWK, publicKeyJWK };\n}\nexport async function encryptPrivateKey<T = AlgorithmType>(\n  privateKeyJWK: JWK<T, \"private\">,\n  password: string\n): Promise<EncryptedPrivateKey<T>> {\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"]\n  );\n\n  const salt = window.crypto.getRandomValues(new Uint8Array(16));\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const privateKeyString = JSON.stringify(privateKeyJWK);\n  const encryptedPrivateKey = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    enc.encode(privateKeyString)\n  );\n\n  return [\n    Buffer.from(encryptedPrivateKey).toString(\"base64\"),\n    Buffer.from(iv).toString(\"base64\"),\n    Buffer.from(salt).toString(\"base64\"),\n  ].join(\".\") as EncryptedPrivateKey<T>;\n}\nexport async function decryptPrivateKey<T = AlgorithmType>(\n  str: TaggedString<[T, \"private\"]>,\n  password: string\n): Promise<JWK<T, \"private\">> {\n  const [encryptedPrivateKey, iv, salt] = str\n    .split(\".\")\n    .map((b64) => Uint8Array.from(Buffer.from(b64, \"base64\")));\n  invariant(encryptedPrivateKey && iv && salt, \"Invalid encrypted private key\");\n  const enc = new TextEncoder();\n  const passwordKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveKey\"]\n  );\n\n  const keyMaterial = await window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 100000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n\n  const decryptedPrivateKey = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    keyMaterial,\n    encryptedPrivateKey\n  );\n\n  const privateKeyJWK = JSON.parse(\n    new TextDecoder().decode(decryptedPrivateKey)\n  );\n  return privateKeyJWK;\n}\nexport async function parseJWS<\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string\n>(jws: J, pubKey?: ECDSACryptoKey<\"public\"> | null) {\n  if (pubKey !== null) {\n    const isValid = await verifyJWS(jws, pubKey);\n    invariant(isValid, `JWS verification failed`);\n  }\n  return parseJWSSync(jws);\n}\nexport function parseJWSSync<\n  T extends { header: unknown; payload: unknown },\n  J extends\n    | string\n    | SignedTransport\n    | SignedBackup\n    | SignedSelfEncrypted = string\n>(\n  jws: J\n): J extends SignedInvitation\n  ? Invitation\n  : J extends SignedReply\n  ? ReplyMessage\n  : J extends SignedReplyToInvite\n  ? ReplyToInvite\n  : J extends SignedSelfEncrypted\n  ? SelfEncrypted\n  : J extends SignedBackup\n  ? BackupJWS\n  : T {\n  invariant(typeof jws === \"string\", \"Expected a string\");\n  if (jws.startsWith('\"') && jws.endsWith('\"')) {\n    jws = jws.slice(1, -1) as any;\n  }\n  const [encodedHeader, encodedPayload] = jws.split(\".\");\n  const header = JSON.parse(b64utoutf8(encodedHeader));\n  let payload = b64utoutf8(encodedPayload);\n  try {\n    payload = JSON.parse(payload);\n  } catch (e) {\n    // ignore JSON parse errors\n  }\n\n  return { header, payload } as any;\n}\n\nexport async function importPrivateKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"private\">\n): Promise<TaggedKey<[T, \"private\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"]\n  )) as TaggedKey<[T, \"private\"]>;\n}\nexport async function importPublicKey<T = AlgorithmType>(\n  type: T,\n  jwk: JWK<T, \"public\">\n): Promise<TaggedKey<[T, \"public\"]>> {\n  return (await window.crypto.subtle.importKey(\n    \"jwk\",\n    jwk,\n    type === \"ECDH\" ? ecdhAlg : ecdsaAlg,\n    true,\n    type === \"ECDH\" ? [] : [\"verify\"]\n  )) as TaggedKey<[T, \"public\"]>;\n}\n\nexport async function importKeyPair<T = AlgorithmType>(\n  t: {\n    privateKeyJWK: JWK<T, \"private\">;\n    publicKeyJWK: JWK<T, \"public\">;\n  },\n  type: \"ecdsa\" | \"ecdh\" = \"ecdh\"\n): Promise<{\n  privateKey: TaggedKey<[T, \"private\"]>;\n  publicKey: TaggedKey<[T, \"public\"]>;\n}> {\n  return {\n    privateKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.privateKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [\"deriveKey\", \"deriveBits\"] : [\"sign\"]\n    )) as TaggedKey<[T, \"private\"]>,\n    publicKey: (await window.crypto.subtle.importKey(\n      \"jwk\",\n      t.publicKeyJWK,\n      type === \"ecdh\" ? ecdhAlg : ecdsaAlg,\n      true,\n      type === \"ecdh\" ? [] : [\"verify\"]\n    )) as TaggedKey<[T, \"public\"]>,\n  };\n}\n\nconst MIN_MESSAGE_SIZE = 30;\nexport async function encryptData<T extends string | object>(\n  secret: SymmetricKey,\n  message: T\n): Promise<{\n  iv: string;\n  encrypted: Encrypted<T>;\n}> {\n  try {\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    let msg = JSON.stringify({\n      m: message,\n    });\n    if (msg.length < MIN_MESSAGE_SIZE) {\n      msg = JSON.stringify({\n        random: ArrayBuffertohex(\n          window.crypto.getRandomValues(new Uint8Array(MIN_MESSAGE_SIZE / 2))\n            .buffer\n        ),\n        m: message,\n      });\n    }\n    const encrypted = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      secret,\n      new TextEncoder().encode(msg)\n    );\n    return {\n      iv: Buffer.from(iv).toString(\"base64\"),\n      encrypted: bufferToB64u(encrypted) as Encrypted<T>,\n    };\n  } catch (e: any) {\n    throw new Error(\"Failed to encrypt \" + e?.message);\n  }\n}\n\nexport async function decryptData<T extends string | object>(\n  secret: SymmetricKey,\n  iv: string,\n  encryptedPayload: Encrypted<T>\n): Promise<T> {\n  try {\n    const payloadBuffer = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: b64uToBuffer(iv),\n      },\n      secret,\n      b64uToBuffer(encryptedPayload)\n    );\n    const decoded = new TextDecoder().decode(payloadBuffer);\n    const decrypted = JSON.parse(decoded);\n\n    return (decrypted?.m ?? decrypted) as T;\n  } catch (e: any) {\n    throw new Error(\"Failed to decrypt \" + e?.message);\n  }\n}\n","import { incMessageId } from \"./index\";\n\nexport type SynAckState = {\n  syn: string | undefined;\n  minAck: string | undefined;\n  maxAck: string | undefined;\n  missing: string[];\n  windowSize: number;\n};\nexport function synAck(\n  id: { syn: string } | { ack: string },\n  state: SynAckState\n) {\n  if (\"syn\" in id) {\n    if (state.syn === undefined) {\n      state.syn = id.syn;\n    } else if (id.syn === incMessageId(state.syn)) {\n      state.syn = id.syn;\n    } else {\n      throw new Error(\n        `Syn out of order ${id.syn} - Expected: ${incMessageId(state.syn)}`\n      );\n    }\n  } else {\n    if (!state.minAck || !state.maxAck) {\n      // initialize\n      state.minAck = id.ack;\n      state.maxAck = id.ack;\n    } else if (id.ack === incMessageId(state.maxAck)) {\n      // Next expected message (max)\n      state.maxAck = id.ack;\n      if (id.ack === incMessageId(state.minAck)) {\n        // min/ax are in sync --- This is the ideal scenario\n        state.minAck = id.ack;\n      }\n    } else if (id.ack === incMessageId(state.minAck)) {\n      // Increment the minAck\n      state.minAck = id.ack;\n    } else if (id.ack <= state.minAck || id.ack === state.maxAck) {\n      // Ignore duplicate\n      return false;\n    } else if (id.ack > state.maxAck) {\n      const min = parseInt(state.minAck, 16);\n      const ack = parseInt(id.ack, 16);\n\n      if (ack - min >= state.windowSize) {\n        throw new Error(\n          `Missing ${ack - min} messages between ${state.minAck} and ${id.ack}`\n        );\n      }\n      if (state.missing.length === 0) {\n        for (let i = min + 1; i < ack; i++) {\n          state.missing.push(i.toString(16));\n        }\n      }\n      const i = state.missing.findIndex((m) => m === id.ack);\n      if (i !== -1) {\n        state.missing.splice(i, 1);\n      }\n      state.maxAck = id.ack;\n    } else {\n      throw new Error(\n        `Ack out of order ${JSON.stringify(id)} ${JSON.stringify(state)}`\n      );\n    }\n  }\n  return true;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { input, rawlist, confirm } from \"@inquirer/prompts\";\nimport { Client, Thumbprint } from \"../client\";\nimport { ThreadID } from \"../client/GridStorage\";\nimport { SignedInvitation, SignedTransport } from \"../client/types\";\nimport { viewEncryptedThread } from \"./viewEncryptedThread\";\nimport { verifyJWS, parseJWSSync, getJWKthumbprint } from \"../client/utils\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\nimport { runWebserver } from \"./runWebserver\";\n\nexport async function mainClientMenu(client: Client) {\n  const invitations = await client.getInvitationIds();\n  const threads = await client.getThreads();\n\n  type Selection =\n    | \"exit\"\n    | \"createInvitation\"\n    | \"replyToInvitation\"\n    | \"webserver\"\n    | ThreadID\n    | Thumbprint<\"ECDH\">;\n  console.clear();\n  const selection = await rawlist<Selection>({\n    message: \"What would you like to do?\",\n    choices: [\n      { name: \"Run local Webserver\", value: \"webserver\" },\n      { name: \"Create Invitation\", value: \"createInvitation\" },\n      ...invitations.map((value) => ({\n        name: `View Invitation: ${value}`,\n        value: value,\n      })),\n      { name: \"Reply to Invitation\", value: \"replyToInvitation\" },\n      ...threads.map((value) => ({\n        name: `View Thread: ${value}`,\n        value: value,\n      })),\n      {\n        name: \"Exit\",\n        value: \"exit\",\n      },\n    ],\n  });\n\n  if (selection === \"exit\") {\n    process.exit(0);\n  } else if (selection === \"createInvitation\") {\n    await createInvitationMenu(client);\n  } else if (selection === \"replyToInvitation\") {\n    await replyToInvitationMenu(client);\n  } else if (selection === \"webserver\") {\n    return runWebserver(client);\n  }\n\n  if (threads.includes(selection as ThreadID)) {\n    await viewEncryptedThread(client, selection as ThreadID);\n  }\n  if (invitations.includes(selection as Thumbprint<\"ECDH\">)) {\n    const invitation = client.getInvitation(selection as Thumbprint<\"ECDH\">);\n    console.log(invitation);\n    const reply = await input({\n      required: false,\n      message:\n        \"If you have received a reply, paste it here, or leave this empty to continue to the main menu\",\n    });\n    if (reply) {\n      const { threadId } = await client.appendThread(reply as SignedTransport);\n      await viewEncryptedThread(client, threadId);\n    }\n  }\n}\n\nasync function createInvitationMenu(client: Client) {\n  const nickname = await input({\n    message: \"What would you like your nickname to be in this conversation?\",\n  });\n  const note = await input({\n    required: false,\n    message: \"(optional) Note to include with the invitation\",\n  });\n\n  const invite = await client.createInvitation({ note, nickname });\n\n  console.log(\n    `Invitation created. Share the text below to allow friends to encrypt messages to you.`\n  );\n  console.log(invite);\n  console.log(\"\\n\\n\\n\");\n}\n\nasync function replyToInvitationMenu(client: Client) {\n  const invite = await input({\n    message: \"Paste the invitation here\",\n  });\n  if (!invite) return;\n  const isValid = await verifyJWS(invite);\n  if (!isValid) {\n    console.log(\"Invalid invite\");\n    return;\n  }\n\n  const jws = parseJWSSync(invite as SignedInvitation);\n  const thumbprint = await getJWKthumbprint(jws.payload.epk);\n\n  console.log(`Invitation Thumbprint: ${thumbprint}`);\n  console.log(`Nickname: ${jws.payload.nickname}`);\n  console.log(`Note: ${jws.payload.note}`);\n\n  const nickname = await input({\n    message: \"What would you like your nickname to be in this conversation?\",\n    required: true,\n  });\n  let setMyRelay = undefined;\n  const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n  const newRelayUrl = `https://ntfy.sh/${ArrayBuffertohex(topicArray.buffer)}`;\n  const message = `Use ${newRelayUrl} to send future messages?`;\n  if (await confirm({ message })) {\n    setMyRelay = newRelayUrl;\n  }\n\n  const reply = await input({\n    required: false,\n    message: \"Enter your reply, or leave empty to cancel\",\n  });\n  if (reply) {\n    const {\n      threadId,\n      reply: message,\n      relay,\n    } = await client.replyToInvitation(\n      invite as SignedInvitation,\n      reply,\n      nickname,\n      { setMyRelay }\n    );\n    await displayRawMessage(message, relay);\n    return viewEncryptedThread(client, threadId);\n  }\n}\nexport async function displayRawMessage(message: string, relay?: string) {\n  console.log(`Here is the message for you to send to the recipient`);\n  console.log(message);\n\n  if (!relay) {\n    await confirm({ message: \"Press enter to continue\" });\n  } else {\n    const sendToRelay = await confirm({\n      message: `Send message to relay? ${relay}`,\n    });\n    if (sendToRelay) {\n      await fetch(relay, {\n        method: \"POST\",\n        body: message,\n      }).catch(console.error);\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { editor, input, select, confirm } from \"@inquirer/prompts\";\nimport { Client } from \"../client\";\nimport { ThreadID } from \"../client/GridStorage\";\nimport { displayRawMessage } from \"./mainClientMenu\";\nimport { SignedTransport } from \"../client/types\";\nimport { ArrayBuffertohex } from \"jsrsasign\";\n\nexport async function viewEncryptedThread(client: Client, threadId: ThreadID) {\n  const thread = await client.decryptThread(threadId);\n  const threadInfo = await client.getThreadInfo(threadId);\n\n  if (threadInfo.myRelay) {\n    let json;\n    try {\n      console.log(`fetching updates from... ${threadInfo.myRelay}`);\n      const response = await fetch(\n        `${threadInfo.myRelay}/json?since=all&poll=1`\n      );\n      const text = await response.text();\n\n      await text\n        .trim()\n        .split(\"\\n\")\n        .reduce(async (p, line) => {\n          await p;\n          json = JSON.parse(line);\n          if (json?.message) {\n            await client.appendThread(json.message, threadId).catch(() => {\n              // Ignore errors about duplicate messages. This is expected.\n            });\n          }\n        }, Promise.resolve());\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  console.log(\n    `Thread: ${threadId}\\n--------------------------------------------`\n  );\n  thread.map((message) => {\n    console.log(\n      `${message.type} From: ${message.from} ${new Date(message.iat * 1000)}\\n${\n        message.message\n      }\\n--------------------------------------------`\n    );\n  });\n\n  const selection = await select({\n    message: \"What would you like to do?\",\n    choices: [\n      threadInfo.myRelay ? { name: \"Refresh\", value: \"refresh\" } : null,\n      { name: \"Reply\", value: \"reply\" },\n      { name: \"Reply (in $EDITOR)\", value: \"replyEditor\" },\n      { name: \"Paste encrypted message\", value: \"paste\" },\n      { name: \"View message details\", value: \"viewDetils\" },\n      {\n        name: threadInfo.myRelay ? \"Change Relay\" : \"Set Relay\",\n        value: \"setRelay\",\n      },\n      { name: \"Back to main menu\", value: \"back\" },\n    ].filter((n) => n != null),\n  });\n\n  switch (selection) {\n    case \"back\":\n      return;\n    case \"setRelay\": {\n      let message =\n        \"Are you sure you want to remove your relay? The operation takes effect while sending a message\";\n      let newRelayUrl = \"\";\n      if (!threadInfo.myRelay) {\n        const topicArray = window.crypto.getRandomValues(new Uint8Array(16));\n        newRelayUrl = `https://ntfy.sh/${ArrayBuffertohex(topicArray.buffer)}`;\n        message = `Use ${newRelayUrl} to send future messages? The operation takes effect while sending a message`;\n      }\n\n      if (await confirm({ message })) {\n        const selection = await select({\n          message: \"What would you like to do?\",\n          choices: [\n            { name: \"Reply\", value: \"reply\" },\n            { name: \"Reply (in $EDITOR)\", value: \"replyEditor\" },\n            { name: \"Back to main menu\", value: \"back\" },\n          ],\n        });\n        if (selection === \"reply\" || selection === \"replyEditor\") {\n          await replyMenu(client, threadId, selection, {\n            setMyRelay: newRelayUrl,\n          });\n        }\n      }\n      break;\n    }\n    case \"replyEditor\":\n    case \"reply\": {\n      await replyMenu(client, threadId, selection);\n      break;\n    }\n    case \"paste\": {\n      const message = await input({\n        required: false,\n        message:\n          \"Paste the encrypted reply you recieved (leave empty to cancel)\",\n      });\n      if (message) {\n        await client.appendThread(message as SignedTransport, threadId);\n      }\n      break;\n    }\n    case \"viewDetils\": {\n      const index = await select({\n        message: \"Which message would you like to inspect?\",\n        choices: thread.map((message, index) => ({\n          name: `From: ${message.from} ${new Date(message.iat * 1000)}\\n${\n            message.message\n          }`,\n          value: index,\n        })),\n      });\n\n      if (index >= 0) {\n        console.log(thread[index]);\n        const encrypted = await client.getEncryptedThread(threadId);\n        console.log(encrypted[index]);\n      }\n    }\n  }\n\n  return viewEncryptedThread(client, threadId);\n}\n\nasync function replyMenu(\n  client: Client,\n  threadId: ThreadID,\n  variant: \"reply\" | \"replyEditor\",\n  options: { setMyRelay?: string } = {}\n) {\n  const prompt = variant === \"reply\" ? input : editor;\n  const message = await prompt({\n    required: false,\n    message: \"Enter your message. (leave empty to cancel)\",\n  });\n  if (message) {\n    const { reply, relay } = await client.replyToThread(threadId, message, {\n      setMyRelay: options.setMyRelay,\n    });\n    await displayRawMessage(reply, relay);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport fastify from \"fastify\";\nimport fstatic from \"@fastify/static\";\nimport fsocket from \"@fastify/websocket\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\nimport { Client } from \"client\";\nimport { invariant } from \"../browser/invariant\";\n\nconst host = \"localhost\";\nconst port = 3000 + Math.floor(Math.random() * 1000);\n\nexport async function runWebserver(client: Client) {\n  const app = fastify({\n    logger: false,\n  });\n  app.register(fsocket);\n  app.register(async (fastify) => {\n    fastify.get(\"/client-socket\", { websocket: true }, async (socket) => {\n      socket.on(\"message\", async (message) => {\n        const data = JSON.parse(message.toString());\n        if (data.requestId && data.method && Array.isArray(data.args)) {\n          const method = client[data.method as keyof Client];\n          if (typeof method === \"function\") {\n            try {\n              // @ts-expect-error I think TS can't verify that the args and return\n              // value match the method\n              const result = await method.apply(client, data.args);\n              socket.send(\n                JSON.stringify({ requestId: data.requestId, result })\n              );\n            } catch (e: any) {\n              socket.send(\n                JSON.stringify({ requestId: data.requestId, error: e?.message })\n              );\n            }\n          }\n        }\n      });\n      socket.send(JSON.stringify({ requestId: \"init\", result: null }));\n    });\n  });\n\n  const root = path.join(__dirname, \"../../dist/\");\n  invariant(fs.access(root), `${root} is not a directory: ${root}`);\n  app.register(fstatic, { root, prefix: \"/WhisperGrid/\" });\n\n  app.get(\"/WhisperGrid\", async (request, reply) => {\n    return reply.sendFile(\"index.html\", root);\n  });\n  app.setNotFoundHandler(async (request, reply) => {\n    if (request.url.startsWith(\"/WhisperGrid\")) {\n      return reply.status(404).sendFile(\"404.html\", root);\n    }\n    if (request.url.startsWith(\"/favicon.ico\")) {\n      return reply.status(404).send();\n    }\n    return reply.redirect(`/WhisperGrid/`);\n  });\n\n  app\n    .listen({\n      host,\n      port,\n    })\n    .then((url) => {\n      console.log(`Server running at ${url}`);\n      console.log(`root: ${root}`);\n    });\n\n  return new Promise(() => {});\n}\n","export function invariant<T>(condition: T, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n"],"names":["$9f203e569b1fab49$var$messageIdForInviteTesting","$bXzvz$inquirerprompts","require","$bXzvz$path","$bXzvz$fs","$bXzvz$crypto","$bXzvz$lodashdebounce","$bXzvz$jsrsasign","$bXzvz$fastify","$bXzvz$fastifystatic","$bXzvz$fastifywebsocket","$bXzvz$fspromises","$parcel$global","globalThis","self","window","global","$parcel$interopDefault","a","__esModule","default","$bf90c0b94bdde3b6$export$9727364c1216843b","str","Buffer","from","replace","$bf90c0b94bdde3b6$export$956a7f8e09e7a04","src","toString","$bf90c0b94bdde3b6$export$1b0a11badccb060e","name","namedCurve","$bf90c0b94bdde3b6$export$593cf972133c6bfa","$bf90c0b94bdde3b6$var$ecdsaKeyUseages","$bf90c0b94bdde3b6$export$a46aded5c6aac828","hash","$bf90c0b94bdde3b6$export$30269e8f0eedc10a","keyPair","crypto","subtle","generateKey","thumbprint","$bf90c0b94bdde3b6$export$d223eef5bee92cf8","$bf90c0b94bdde3b6$export$96341dfa0e2e9076","publicKey","$9f203e569b1fab49$export$89cea9803cad95d2","$bf90c0b94bdde3b6$export$b1dda1088d254686","$bf90c0b94bdde3b6$export$f5708dca728d7177","condition","message","Error","$bf90c0b94bdde3b6$export$d8c619be39dc35fe","privateKey","bits","deriveBits","public","importKey","$bf90c0b94bdde3b6$export$d71a6df60c6808b","header","payload","unixTimetsamp","Math","floor","Date","now","iat","encodedHeader","utf8tob64u","JSON","stringify","encodedPayload","dataToSign","signature","sign","TextEncoder","encode","encodedSignature","hextob64u","ArrayBuffertohex","$bf90c0b94bdde3b6$export$bcc5355044a25ec","jws","pubKey","startsWith","endsWith","slice","split","signedData","headerObj","parse","b64utoutf8","e","jwk","$bf90c0b94bdde3b6$export$f7283e97187223bd","verify","hextoArrayBuffer","b64utohex","kty","s","crf","crv","x","y","hex","rstrtohex","sha256","digest","alg","key","exportKey","$bf90c0b94bdde3b6$export$87d43765c0bdfdff","privateKeyJWK","publicKeyJWK","$bf90c0b94bdde3b6$export$4f5b87a5ef040005","password","enc","passwordKey","salt","getRandomValues","Uint8Array","keyMaterial","deriveKey","iterations","length","iv","privateKeyString","encryptedPrivateKey","encrypt","join","$bf90c0b94bdde3b6$export$c97f585acdba2853","map","b64","decryptedPrivateKey","decrypt","TextDecoder","decode","$bf90c0b94bdde3b6$export$99859bc1ea511bf9","$bf90c0b94bdde3b6$export$56ce858a5181ed60","$bf90c0b94bdde3b6$export$a130e185e3431961","type","$bf90c0b94bdde3b6$export$57926b65d55505fc","t","$bf90c0b94bdde3b6$export$cfb0e8a6f536315e","secret","msg","m","random","$bf90c0b94bdde3b6$var$MIN_MESSAGE_SIZE","buffer","encrypted","$bf90c0b94bdde3b6$export$989b3bbdce9ac2d4","encryptedPayload","payloadBuffer","decoded","decrypted","Symbol","$fec366f672fe5d29$export$8688904fb0eaa63d","data","Map","debugData","Object","fromEntries","entries","loadIdentityBackup","backup","setItem","identity","invites","forEach","value","appendItem","unique","encryptedThreadKeys","threads","id","thread","threadInfo","messages","makeIdentityBackup","idPrivateKey","storagePrivateKey","getItem","private","storage","queryItem","reduce","memo","myThumbprint","Promise","resolve","hasItem","has","removeItem","delete","get","set","arr","Array","isArray","includes","push","storeMessage","threadId","messageId","index","min","max","readMessages","$9f203e569b1fab49$var$keyNicknames","nickname","$9f203e569b1fab49$export$1a98f7a90e54a705","substring","$9f203e569b1fab49$var$MAX_MESSAGE_ID","Number","MAX_SAFE_INTEGER","$9f203e569b1fab49$export$1f2bb630327ac4b6","identityKeyPair","storageKeyPair","isLocalClient","clientNickname","setClientNickname","constructor","subscriptions","Set","getThumbprint","generateClient","storageKey","idJWKs","storageJWKs","encryptedIdentity","encryptedStorageKey","loadClient","loadFromBackup","identityPrivateKey","storedData","decryptFromSelf","selfEncrypted","epk","encryptToSelf","jwks","sub","encryptedJWS","decryptedMessage","createInvitation","note","makeThreadKeys","invitation","signedInvitation","notifySubscribers","replyToInvitation","signedInvite","setMyRelay","invite","startThread","replyToThread","selfSign","theirEPKJWK","theirSignature","signatureThumbprint","thumbprints","sort","missing","windowSize","maxAck","undefined","minAck","syn","theirEPK","relays","appendThread","getThreads","getInvitationIds","getInvitations","getInvitation","threadKey","keyBackup","readThreadSecret","threadThumbprint","publicJWK","encryptedBackup","pKey","options","parseInt","nextId","$9f203e569b1fab49$export$af15847d6300ede1","replyMessage","re","relay","theirThumbprint","reply","encryptedMessage","invitationThumbprint","invitationJWS","fromMe","decryptMessage","fromThumbprint","state","ack","i","findIndex","splice","messageIndex","indexOf","match","console","warn","decryptThread","getEncryptedThread","all","b","localeCompare","jwsInvite","epkThumbprint","getThreadInfo","myRelay","myNickname","theirNickname","makeBackup","subscribe","onChange","add","isNaN","n","$130b50bf591698bb$export$5d1a368113f048de","client","json","log","response","fetch","text","trim","p","line","catch","error","selection","select","choices","filter","newRelayUrl","topicArray","confirm","$130b50bf591698bb$var$replyMenu","input","required","variant","prompt","editor","$50dcff3ae6a8aa6d$export$1a84ddaebc60eb8a","$9282f0b1a67aebb3$var$$parcel$__dirname","__dirname","$9282f0b1a67aebb3$var$port","$9282f0b1a67aebb3$export$5640fea681d7e95f","app","logger","register","fastify","websocket","socket","on","requestId","method","args","result","apply","send","root","access","prefix","request","sendFile","setNotFoundHandler","url","status","redirect","listen","host","port","then","$50dcff3ae6a8aa6d$export$6dcc8f92a4b45952","invitations","clear","rawlist","process","exit","$50dcff3ae6a8aa6d$var$createInvitationMenu","$50dcff3ae6a8aa6d$var$replyToInvitationMenu","body","$a09f43455a860df9$var$makeNewIdentity","pass1","tries","pass2","filename","promises","writeFile","$a09f43455a860df9$var$main","jwsTxtFiles","files","readdir","file","basename","pass","readFile"],"version":3,"file":"index.js.map","sourceRoot":"../../"}
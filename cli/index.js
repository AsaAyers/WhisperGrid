let e;var t=require("@inquirer/prompts"),a=require("path"),i=require("fs"),r=require("crypto"),s=require("lodash.debounce"),n=require("jsrsasign"),o=require("fastify"),y=require("@fastify/static"),l=require("@fastify/websocket"),c=require("fs/promises"),d="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function h(e){return e&&e.__esModule?e.default:e}const u=e=>Buffer.from(e.replace("-","+").replace("_","/"),"base64"),m=e=>Buffer.from(e).toString("base64").replace("+","-").replace("/","_").replace("=",""),p={name:"ECDH",namedCurve:"P-384"},w={name:"ECDSA",namedCurve:"P-384"},g=["sign","verify"],f={name:"ECDSA",hash:{name:"SHA-384"}};async function b(){let e=await window.crypto.subtle.generateKey(w,!0,g),t=await S(await T(e.publicKey));return C(t,`${t}/ECDSA`),e}async function k(){let e=await window.crypto.subtle.generateKey(p,!0,["deriveKey","deriveBits"]),t=await S(await T(e.publicKey));return C(t,`${t}/ECDH`),e}function v(e,t){if(!e)throw Error(t)}async function I(e,t){let a=await window.crypto.subtle.deriveBits({name:p.name,public:t},e,256);return await window.crypto.subtle.importKey("raw",a,{name:"AES-GCM"},!1,["encrypt","decrypt"])}async function K(e,t,a){let i=Math.floor(Date.now()/1e3);e.iat=i;let r=(0,n.utf8tob64u)(JSON.stringify(e)),s=(0,n.utf8tob64u)("string"==typeof t?t:JSON.stringify(t)),o=`${r}.${s}`,y=await window.crypto.subtle.sign(f,a,new TextEncoder().encode(o)),l=(0,n.hextob64u)((0,n.ArrayBuffertohex)(y));return`${o}.${l}`}async function $(e,t){e.startsWith('"')&&e.endsWith('"')&&(e=e.slice(1,-1));let[a,i,r]=e.split("."),s=`${a}.${i}`;if(!t){let t;try{t=JSON.parse((0,n.b64utoutf8)(a))}catch(e){}return!!t&&"jwk"in t&&"object"==typeof t.jwk&&$(e,await P("ECDSA",t.jwk))}return"kty"in t&&(t=await P("ECDSA",t)),await window.crypto.subtle.verify({name:w.name,hash:{name:"SHA-384"}},t,(0,n.hextoArrayBuffer)((0,n.b64utohex)(r)),new TextEncoder().encode(s))}async function S(e){v("EC"===e.kty,"Unsupported key type");let t={crf:e.crv,kty:e.kty,x:e.x,y:e.y},a=(0,n.rstrtohex)(JSON.stringify(t)),i=await window.crypto.subtle.digest("SHA-256",(0,n.hextoArrayBuffer)(a)),r=e.alg?`${e.alg}/`:"";return`id-${r}${(0,n.hextob64u)((0,n.ArrayBuffertohex)(i))}`}function T(e){return window.crypto.subtle.exportKey("jwk",e)}async function E(e){return{privateKeyJWK:await T(e.privateKey),publicKeyJWK:await T(e.publicKey)}}async function A(e,t){let a=new TextEncoder,i=await window.crypto.subtle.importKey("raw",a.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),r=window.crypto.getRandomValues(new Uint8Array(16)),s=await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),n=window.crypto.getRandomValues(new Uint8Array(12)),o=JSON.stringify(e),y=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:n},s,a.encode(o));return[Buffer.from(y).toString("base64"),Buffer.from(n).toString("base64"),Buffer.from(r).toString("base64")].join(".")}async function x(e,t){let[a,i,r]=e.split(".").map(e=>Uint8Array.from(Buffer.from(e,"base64")));v(a&&i&&r,"Invalid encrypted private key");let s=new TextEncoder,n=await window.crypto.subtle.importKey("raw",s.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),o=await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),y=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:i},o,a);return JSON.parse(new TextDecoder().decode(y))}async function N(e,t){return null!==t&&v(await $(e,t),"JWS verification failed"),J(e)}function J(e){v("string"==typeof e,"Expected a string"),e.startsWith('"')&&e.endsWith('"')&&(e=e.slice(1,-1));let[t,a]=e.split("."),i=JSON.parse((0,n.b64utoutf8)(t)),r=(0,n.b64utoutf8)(a);try{r=JSON.parse(r)}catch(e){}return{header:i,payload:r}}async function W(e,t){return await window.crypto.subtle.importKey("jwk",t,"ECDH"===e?p:w,!0,"ECDH"===e?["deriveKey","deriveBits"]:["sign"])}async function P(e,t){return await window.crypto.subtle.importKey("jwk",t,"ECDH"===e?p:w,!0,"ECDH"===e?[]:["verify"])}async function M(e,t="ecdh"){return{privateKey:await window.crypto.subtle.importKey("jwk",e.privateKeyJWK,"ecdh"===t?p:w,!0,"ecdh"===t?["deriveKey","deriveBits"]:["sign"]),publicKey:await window.crypto.subtle.importKey("jwk",e.publicKeyJWK,"ecdh"===t?p:w,!0,"ecdh"===t?[]:["verify"])}}async function j(e,t){try{let a=window.crypto.getRandomValues(new Uint8Array(12)),i=JSON.stringify({m:t});i.length<30&&(i=JSON.stringify({random:(0,n.ArrayBuffertohex)(window.crypto.getRandomValues(new Uint8Array(15)).buffer),m:t}));let r=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:a},e,new TextEncoder().encode(i));return{iv:Buffer.from(a).toString("base64"),encrypted:m(r)}}catch(e){throw Error("Failed to encrypt "+e?.message)}}async function R(e,t,a){try{let i=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:u(t)},e,u(a)),r=new TextDecoder().decode(i),s=JSON.parse(r);return s?.m??s}catch(e){throw Error("Failed to decrypt "+e?.message)}}Symbol("keySymbol");class B{data=new Map;debugData(){return Object.fromEntries(this.data.entries())}async loadIdentityBackup(e){this.setItem(`identity:${e.thumbprint}`,e.identity),Object.entries(e.invites??{}).forEach(([t,a])=>{this.appendItem(`invitations:${e.thumbprint}`,t,{unique:!0}),this.setItem(`invitation:${t}`,a)}),Object.entries(e.encryptedThreadKeys).forEach(([e,t])=>{this.setItem(`encrypted-thread-key:${e}`,t)}),Object.entries(e.threads).forEach(([t,a])=>{this.appendItem(`threads:${e.thumbprint}`,t),this.setItem(`thread-info:${e.thumbprint}:${t}`,a.threadInfo),this.setItem(`keyed-messages:${e.thumbprint}:${t}`,a.messages)})}async makeIdentityBackup(e,t,a){let i=this.getItem(`identity:${e}`),r={};return{thumbprint:e,identity:{id:{jwk:i.id.jwk,private:t},storage:{jwk:i.storage.jwk,private:a}},invites:this.queryItem(`invitations:${e}`)?.reduce((e,t)=>(e[t]=this.getItem(`invitation:${t}`),r[t]=this.getItem(`encrypted-thread-key:${t}`),e),{}),threads:await this.queryItem(`threads:${e}`)?.reduce(async(t,a)=>{let i=await t,s=this.getItem(`thread-info:${e}:${a}`),n=this.getItem(`keyed-messages:${e}:${a}`);return r[s.myThumbprint]=this.getItem(`encrypted-thread-key:${s.myThumbprint}`),i[a]={threadInfo:s,messages:n},i},Promise.resolve({}))??{},encryptedThreadKeys:r}}hasItem=e=>this.data.has(e);removeItem=e=>(this.data.delete(e),null);queryItem=e=>this.data.get(e);getItem=e=>(v(this.hasItem(e),`Key ${e} not found in storage.`),this.data.get(e));setItem=(e,t)=>{this.data.set(e,t)};appendItem=(e,t,{unique:a=!1}={})=>{let i=this.queryItem(e);Array.isArray(i)||(i=[]),a&&i.includes(t)||(i.push(t),this.setItem(e,i))};storeMessage(e,t,a,i){let r=this.queryItem(`keyed-messages:${e}:${t}`)??{min:a,max:a,messages:[]};r.messages.push(i),this.setItem(`keyed-messages:${e}:${t}`,r)}readMessages(e,t){let{messages:a}=this.getItem(`keyed-messages:${e}:${t}`);return a}}const q=new Map;function C(e,t){q.set(e,t)}function D(e){return q.get(e)+"_"+e.substring(e.length-6)}const O=Number.MAX_SAFE_INTEGER/2;class F{storage;thumbprint;identityKeyPair;storageKeyPair;clientNickname;async setClientNickname(e){this.clientNickname=e,e&&(C(this.thumbprint,this.clientNickname),C(await S(await T(this.storageKeyPair.publicKey)),`storage[${this.clientNickname}]`))}constructor(e,t,a,i){this.storage=e,this.thumbprint=t,this.identityKeyPair=a,this.storageKeyPair=i,this.clientNickname=Math.random().toString(36).slice(2),this.subscriptions=new Set}async getThumbprint(){return this.thumbprint}static async generateClient(e,t){let a=await b(),i=await k(),r=await E(a),s=await E(i),n=await A(r.privateKeyJWK,t),o=await A(s.privateKeyJWK,t),y=await S(r.publicKeyJWK);return e.setItem(`identity:${y}`,{id:{jwk:r.publicKeyJWK,private:n},storage:{jwk:s.publicKeyJWK,private:o}}),F.loadClient(e,y,t)}static async loadFromBackup(e,t,a){if("string"==typeof t){let i=await N(t);return F.loadFromBackup(e,i.payload,a)}let i=await x(t.identity.id.private,a),r=await x(t.identity.storage.private,a),s=await M({privateKeyJWK:i,publicKeyJWK:t.identity.id.jwk},"ecdsa"),n=await M({privateKeyJWK:r,publicKeyJWK:t.identity.storage.jwk},"ecdh");return await e.loadIdentityBackup(t),new F(e,t.thumbprint,s,n)}static async loadClient(e,t,a){let i=e.getItem(`identity:${t}`);v(i,"No identity found for thumbprint");let r=await x(i.id.private,a);return new F(e,t,await M({privateKeyJWK:r,publicKeyJWK:i.id.jwk},"ecdsa"),await M({privateKeyJWK:await x(i.storage.private,a),publicKeyJWK:i.storage.jwk},"ecdh"))}async decryptFromSelf(e){let t=await N(e,this.identityKeyPair.publicKey),a=await P("ECDH",t.header.epk),i=await I(this.storageKeyPair.privateKey,a);return await R(i,t.header.iv,t.payload)}async encryptToSelf(e){let t=await k(),a=await E(t),i=await I(t.privateKey,this.storageKeyPair.publicKey),{iv:r,encrypted:s}=await j(i,e),n={header:{alg:"ES384",jwk:(await E(this.identityKeyPair)).publicKeyJWK,iat:0,sub:"self-encrypted",iv:r,epk:a.publicKeyJWK},payload:s},o=await K(n.header,n.payload,this.identityKeyPair.privateKey);v(await $(o),"Error encrypting message");let y=await this.decryptFromSelf(o);return v(y,"Decrypted message is empty"),v(y===e||e===JSON.stringify(y),"Decrypted message mismatch"),o}async createInvitation({note:t,nickname:a}){let{thumbprint:i,jwks:r}=await this.makeThreadKeys(),s={header:{alg:"ES384",jwk:(await E(this.identityKeyPair)).publicKeyJWK,iat:0,sub:"grid-invitation"},payload:{messageId:Number(e??Math.floor(Math.random()*O)).toString(16),epk:r.publicKeyJWK,note:t,nickname:a}},n=await K(s.header,s.payload,this.identityKeyPair.privateKey);return this.storage.setItem(`invitation:${i}`,n),this.storage.appendItem(`invitations:${this.thumbprint}`,i,{unique:!0}),this.storage.setItem(`threads:${this.thumbprint}`,this.storage.queryItem(`threads:${this.thumbprint}`)??[]),this.notifySubscribers(),n}async replyToInvitation(e,t,a,{setMyRelay:i}={}){v(await $(e),"Invalid invitation signature");let r=await N(e),s=await this.startThread(e,r.payload.epk,r.header.jwk);return this.replyToThread(s,t,{selfSign:!0,nickname:a,setMyRelay:i})}async startThread(e,t,a,i){if(!i){let{thumbprint:e}=await this.makeThreadKeys();i=e}v(this.storage.getItem(`encrypted-thread-key:${i}`),`Thread key not found ${i}`);let r=await S(a);v(!i||r!==this.thumbprint,"Cannot start a thread with yourself");let s=[await S(t),i].sort(),o=(0,n.ArrayBuffertohex)(await window.crypto.subtle.digest("SHA-256",Buffer.from(s.join(":"))));return this.storage.setItem(`thread-info:${this.thumbprint}:${o}`,{missing:[],windowSize:5,maxAck:void 0,minAck:void 0,syn:void 0,myThumbprint:i,theirEPK:t,signedInvite:e,theirSignature:a,relays:{}}),this.storage.appendItem(`threads:${this.thumbprint}`,o),await this.appendThread(e,o),this.notifySubscribers(),o}async getThreads(){return this.storage.queryItem(`threads:${this.thumbprint}`)??[]}async getInvitationIds(){return this.storage.queryItem(`invitations:${this.thumbprint}`)??[]}async getInvitations(){return(await this.getInvitationIds()).map(e=>this.storage.getItem(`invitation:${e}`))}async getInvitation(e){return this.storage.getItem(`invitation:${e}`)}async makeThreadKeys(){let e=await k(),t=await E(e),a=await S(t.publicKeyJWK);C(a,`thread[${this.clientNickname}]`);let i=await this.encryptToSelf(JSON.stringify(t));return this.storage.setItem(`encrypted-thread-key:${a}`,i),{thumbprint:a,jwks:t}}async readThreadSecret(e){let t=this.storage.getItem(`thread-info:${this.thumbprint}:${e}`);v(t,"Thread not found");let a=t.theirEPK;v(a,`Public key not found ${t.theirEPK}`);let i=this.storage.getItem(`encrypted-thread-key:${t.myThumbprint}`);v("string"==typeof i,`Thread key not found ${t.myThumbprint}`);let r=JSON.parse(await this.decryptFromSelf(i)),s=await P("ECDH",a),n=await W("ECDH",r.privateKeyJWK);return{secret:await I(n,s),epk:r.publicKeyJWK}}async replyToThread(t,a,i){let{secret:r,epk:s}=await this.readThreadSecret(t),n=this.storage.getItem(`thread-info:${this.thumbprint}:${t}`);v(n,"Thread not found");let o=n.syn??Number(e?parseInt("100000",16)+e:Math.floor(Math.random()*O)).toString(16);v("string"==typeof o,`Invalid message id ${o}`);let y=H(o);i?.setMyRelay&&(n.relays[this.thumbprint]=i.setMyRelay),v(n.minAck,`Missing minAck in "thread-info" ${a}`);let l={header:{iat:0,alg:"ES384",sub:"grid-reply",re:t,iv:"",from:this.thumbprint},payload:{messageId:y,message:a,minAck:n.minAck}};this.storage.setItem(`thread-info:${this.thumbprint}:${t}`,n),i?.selfSign&&i.nickname&&(l={header:{...l.header,sub:"reply-to-invite",jwk:await T(this.identityKeyPair.publicKey),invite:await S(n.theirEPK),epk:s},payload:{...l.payload,nickname:i.nickname,messageId:Number(e?parseInt("100000",16)+e:Math.floor(Math.random()*O)).toString(16)}}),i?.setMyRelay&&(l.payload.relay=i.setMyRelay);let{iv:c,encrypted:d}=await j(r,l.payload);l.header.iv=c;let h=await K(l.header,d,this.identityKeyPair.privateKey);v($(h,this.identityKeyPair.publicKey),"Error encrypting message");let u=await S(n.theirSignature),m=n.relays[u];return await this.appendThread(h,t),{reply:h,threadId:t,relay:m}}async appendThread(e,t){let a=J(e);if(!t)switch(a.header.sub){case"grid-invitation":throw Error("Not Implemented");case"reply-to-invite":{v($(e),"Expected a self-signed message"),v(a.header.epk,"First message must have an epk"),v(a.header.invite,'First message must have an "invite" header');let i=a.header.invite,r=this.storage.getItem(`invitation:${i}`);v(r,"Invitation not found "+i);let s=await N(r),n=await S(s.payload.epk);t=await this.startThread(r,a.header.epk,a.header.jwk,n)}case"grid-reply":{t??=a.header.re;let i=this.storage.getItem(`thread-info:${this.thumbprint}:${t}`),r=a.header.from===this.thumbprint;return v(r?await $(e,this.identityKeyPair.publicKey):await $(e,i.theirSignature),"Invalid message signature"),this.appendThread(e,t)}}v(t,"Thread not found");let i=await this.decryptMessage(t,e),r={...this.storage.getItem(`thread-info:${this.thumbprint}:${t}`)},s=i.fromThumbprint===this.thumbprint;if(v(s?await $(e,this.identityKeyPair.publicKey):await $(e,r.theirSignature),"Invalid message signature"),function(e,t){if("syn"in e){if(void 0===t.syn)t.syn=e.syn;else if(e.syn===H(t.syn))t.syn=e.syn;else throw Error(`Syn out of order ${e.syn} - Expected: ${H(t.syn)}`)}else if(t.minAck&&t.maxAck){if(e.ack===H(t.maxAck))t.maxAck=e.ack,e.ack===H(t.minAck)&&(t.minAck=e.ack);else if(e.ack===H(t.minAck))t.minAck=e.ack;else if(e.ack<=t.minAck||e.ack===t.maxAck)return!1;else if(e.ack>t.maxAck){let a=parseInt(t.minAck,16),i=parseInt(e.ack,16);if(i-a>=t.windowSize)throw Error(`Missing ${i-a} messages between ${t.minAck} and ${e.ack}`);if(0===t.missing.length)for(let e=a+1;e<i;e++)t.missing.push(e.toString(16));let r=t.missing.findIndex(t=>t===e.ack);-1!==r&&t.missing.splice(r,1),t.maxAck=e.ack}else throw Error(`Ack out of order ${JSON.stringify(e)} ${JSON.stringify(t)}`)}else t.minAck=e.ack,t.maxAck=e.ack;return!0}(s?{syn:i.messageId}:{ack:i.messageId},r)){let s=this.storage.queryItem(`keyed-messages:${this.thumbprint}:${t}`)?.messages;v(!s||!s.includes(e),`Message already exists in thread ${JSON.stringify({nickname:this.clientNickname,messageId:i.messageId,sub:a.header.sub,threadId:t,messageIndex:s?.indexOf(e)},null,2)}`),i.relay&&(r.relays[await S(r.theirSignature)]=i.relay,i.relay&&i.relay.match(/^https?:\/\/ntfy.sh\/[^.]+$/)&&(r.relays[this.thumbprint]=i.relay)),this.storage.setItem(`thread-info:${this.thumbprint}:${t}`,r),this.storage.storeMessage(this.thumbprint,t,i.messageId,e),this.notifySubscribers()}else console.warn("Skipping message",i.messageId);return{threadId:t,message:i,relay:i.relay}}async decryptThread(e){let t=await this.getEncryptedThread(e),a=await Promise.all(t.map(async t=>"string"==typeof t?this.decryptMessage(e,t):t));return a.sort((e,t)=>e.from!==t.from&&(e.minAck&&e.minAck<t.messageId||t.minAck&&t.minAck<e.messageId)?1:("invite"===e.type?-1:0)||("invite"===t.type?1:0)||t.iat-e.iat||(e.from===t.from?e.messageId.localeCompare(t.messageId):0)),a}async decryptMessage(e,t){let a=this.storage.getItem(`thread-info:${this.thumbprint}:${e}`),i=await N(t,null);if(v(a,"Thread not found"),"grid-invitation"===i.header.sub){v(await $(t),"Invalid message signature");let e=`Invite from ${i.payload.nickname}.
Note: ${i.payload.note??"(none)"}`,a=await S(i.header.jwk);return i.payload.nickname&&C(a,i.payload.nickname),{from:D(a),fromThumbprint:a,epkThumbprint:await S(i.payload.epk),message:e,type:"invite",iat:i.header.iat,messageId:i.payload.messageId,minAck:void 0}}let{secret:r}=await this.readThreadSecret(e),s=await R(r,i.header.iv,i.payload),n=i.header.from,o=n===await S(a.theirSignature)?await S(a.theirEPK):a.myThumbprint;return{from:D(n),fromThumbprint:n,epkThumbprint:o,message:s.message,type:"message",iat:i.header.iat,messageId:s.messageId,minAck:s.minAck,relay:s.relay}}async getEncryptedThread(e){return this.storage.readMessages(this.thumbprint,e)}async getThreadInfo(e){let t=this.storage.getItem(`thread-info:${this.thumbprint}:${e}`);return v(t,"Thread not found"),{myRelay:t.relays[this.thumbprint],myNickname:D(this.thumbprint),theirNickname:D(await S(t.theirSignature))}}async makeBackup(e){let t=await E(this.identityKeyPair),a=await E(this.storageKeyPair),i=await A(t.privateKeyJWK,e),r=await A(a.privateKeyJWK,e),s=await this.storage.makeIdentityBackup(this.thumbprint,i,r);return K({alg:"ES384",jwk:t.publicKeyJWK},s,this.identityKeyPair.privateKey)}notifySubscribers(){for(let e of this.subscriptions)try{e?.()}catch(e){}}subscriptions;subscribe(e){return this.subscriptions??=new Set,this.subscriptions.add(e),()=>{this.subscriptions.delete(e)}}}function H(e){let t=parseInt(e,16)+1;t>=O&&(t=1),v(!Number.isNaN(t),`Invalid message id ${e} ${t}`);let a=t.toString(16);return v(!Number.isNaN(a),`Invalid message toString ${e} ${t}`),a}async function G(e,a){let i=await e.decryptThread(a),r=await e.getThreadInfo(a);if(r.myRelay){let t;try{console.log(`fetching updates from... ${r.myRelay}`);let i=await fetch(`${r.myRelay}/json?since=all&poll=1`),s=await i.text();await s.trim().split("\n").reduce(async(i,r)=>{await i,t=JSON.parse(r),t?.message&&await e.appendThread(t.message,a).catch(()=>{})},Promise.resolve())}catch(e){console.error(e)}}console.log(`Thread: ${a}
--------------------------------------------`),i.map(e=>{console.log(`${e.type} From: ${e.from} ${new Date(1e3*e.iat)}
${e.message}
--------------------------------------------`)});let s=await (0,t.select)({message:"What would you like to do?",choices:[r.myRelay?{name:"Refresh",value:"refresh"}:null,{name:"Reply",value:"reply"},{name:"Reply (in $EDITOR)",value:"replyEditor"},{name:"Paste encrypted message",value:"paste"},{name:"View message details",value:"viewDetils"},{name:r.myRelay?"Change Relay":"Set Relay",value:"setRelay"},{name:"Back to main menu",value:"back"}].filter(e=>null!=e)});switch(s){case"back":return;case"setRelay":{let i="Are you sure you want to remove your relay? The operation takes effect while sending a message",s="";if(!r.myRelay){let e=window.crypto.getRandomValues(new Uint8Array(16));s=`https://ntfy.sh/${(0,n.ArrayBuffertohex)(e.buffer)}`,i=`Use ${s} to send future messages? The operation takes effect while sending a message`}if(await (0,t.confirm)({message:i})){let i=await (0,t.select)({message:"What would you like to do?",choices:[{name:"Reply",value:"reply"},{name:"Reply (in $EDITOR)",value:"replyEditor"},{name:"Back to main menu",value:"back"}]});("reply"===i||"replyEditor"===i)&&await U(e,a,i,{setMyRelay:s})}break}case"replyEditor":case"reply":await U(e,a,s);break;case"paste":{let i=await (0,t.input)({required:!1,message:"Paste the encrypted reply you recieved (leave empty to cancel)"});i&&await e.appendThread(i,a);break}case"viewDetils":{let r=await (0,t.select)({message:"Which message would you like to inspect?",choices:i.map((e,t)=>({name:`From: ${e.from} ${new Date(1e3*e.iat)}
${e.message}`,value:t}))});r>=0&&(console.log(i[r]),console.log((await e.getEncryptedThread(a))[r]))}}return G(e,a)}async function U(e,a,i,r={}){let s="reply"===i?t.input:t.editor,n=await s({required:!1,message:"Enter your message. (leave empty to cancel)"});if(n){let{reply:t,relay:i}=await e.replyToThread(a,n,{setMyRelay:r.setMyRelay});await Q(t,i)}}var V=a.resolve(__dirname,"../../src/cli");const _=3e3+Math.floor(1e3*Math.random());async function z(e){let t=h(o)({logger:!0});t.register(h(l)),t.register(async t=>{t.get("/client-socket",{websocket:!0},async t=>{t.on("message",async a=>{let i=JSON.parse(a.toString());if(i.requestId&&i.method&&Array.isArray(i.args)){let a=e[i.method];if("function"==typeof a)try{let r=await a.apply(e,i.args);t.send(JSON.stringify({requestId:i.requestId,result:r}))}catch(e){t.send(JSON.stringify({requestId:i.requestId,error:e?.message}))}}})})});let i=h(a).join(V,"../../dist/");return!function(e,t){if(!e)throw Error(t)}(h(c).access(i),`${i} is not a directory: ${i}`),t.register(h(y),{root:i,prefix:"/WhisperGrid/"}),t.get("/WhisperGrid",async(e,t)=>t.sendFile("index.html",i)),t.setNotFoundHandler(async(e,t)=>e.url.startsWith("/WhisperGrid")?t.status(404).sendFile("404.html",i):e.url.startsWith("/favicon.ico")?t.status(404).send():t.redirect("/WhisperGrid/")),t.listen({host:"localhost",port:_}).then(e=>{console.log(`Server running at ${e}`),console.log(`root: ${i}`)}),new Promise(()=>{})}async function X(e){let a=await e.getInvitationIds(),i=await e.getThreads();console.clear();let r=await (0,t.rawlist)({message:"What would you like to do?",choices:[{name:"Run local Webserver",value:"webserver"},{name:"Create Invitation",value:"createInvitation"},...a.map(e=>({name:`View Invitation: ${e}`,value:e})),{name:"Reply to Invitation",value:"replyToInvitation"},...i.map(e=>({name:`View Thread: ${e}`,value:e})),{name:"Exit",value:"exit"}]});if("exit"===r)process.exit(0);else if("createInvitation"===r)await Y(e);else if("replyToInvitation"===r)await L(e);else if("webserver"===r)return z(e);if(i.includes(r)&&await G(e,r),a.includes(r)){console.log(e.getInvitation(r));let a=await (0,t.input)({required:!1,message:"If you have received a reply, paste it here, or leave this empty to continue to the main menu"});if(a){let{threadId:t}=await e.appendThread(a);await G(e,t)}}}async function Y(e){let a=await (0,t.input)({message:"What would you like your nickname to be in this conversation?"}),i=await (0,t.input)({required:!1,message:"(optional) Note to include with the invitation"}),r=await e.createInvitation({note:i,nickname:a});console.log("Invitation created. Share the text below to allow friends to encrypt messages to you."),console.log(r),console.log("\n\n\n")}async function L(e){let a;let i=await (0,t.input)({message:"Paste the invitation here"});if(!i)return;if(!await $(i)){console.log("Invalid invite");return}let r=J(i),s=await S(r.payload.epk);console.log(`Invitation Thumbprint: ${s}`),console.log(`Nickname: ${r.payload.nickname}`),console.log(`Note: ${r.payload.note}`);let o=await (0,t.input)({message:"What would you like your nickname to be in this conversation?",required:!0}),y=window.crypto.getRandomValues(new Uint8Array(16)),l=`https://ntfy.sh/${(0,n.ArrayBuffertohex)(y.buffer)}`,c=`Use ${l} to send future messages?`;await (0,t.confirm)({message:c})&&(a=l);let d=await (0,t.input)({required:!1,message:"Enter your reply, or leave empty to cancel"});if(d){let{threadId:t,reply:r,relay:s}=await e.replyToInvitation(i,d,o,{setMyRelay:a});return await Q(r,s),G(e,t)}}async function Q(e,a){console.log("Here is the message for you to send to the recipient"),console.log(e),a?await (0,t.confirm)({message:`Send message to relay? ${a}`})&&await fetch(a,{method:"POST",body:e}).catch(console.error):await (0,t.confirm)({message:"Press enter to continue"})}async function Z(){let e="";for(let a=0;a<3;a++){e=await (0,t.password)({message:"Enter pass phrase to encrypt your new identity"});let a=await (0,t.password)({message:"Enter pass phrase again to confirm"});if(e===a)break;console.error("Passwords do not match")}let a=await F.generateClient(new B,e),r=`grid-${await a.getThumbprint()}.jws.txt`;for(a.subscribe(h(s)(async()=>{let t=await a.makeBackup(e);await (0,i.promises).writeFile(r,t)},500));;)await X(a)}d.window??={},window.crypto=h(r),async function(){console.clear();let e=(await (0,i.promises).readdir(".")).filter(e=>e.endsWith(".jws.txt"));if(!(e.length>0))return"no"===await (0,t.select)({message:"No backup files found. Would you like to create a new identity?",choices:[{name:"Yes",value:"yes"},{name:"No",value:"no"}]})&&process.exit(0),Z();{let r=await (0,t.rawlist)({message:"Which file would you like to open?",choices:[...e.map(e=>({name:a.basename(e,".jws.txt"),value:e})),{value:"newIdentity",name:"Create a new identity"}]});if("newIdentity"===r)return Z();let n=await (0,t.password)({message:"Enter pass phrase to decrypt file"}),o=await (0,i.promises).readFile(r,"utf-8");try{let e=await F.loadFromBackup(new B,o,n);for(e.subscribe(h(s)(async()=>{let t=await e.makeBackup(n);await (0,i.promises).writeFile(r,t)},500));;)await X(e)}catch(e){console.error("Error loading backup",e),process.exit(1)}}}();
//# sourceMappingURL=index.js.map
